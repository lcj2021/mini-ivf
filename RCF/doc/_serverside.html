
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_serverside.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Server-side Programming </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Configure">Configuring a Server</a><ul><li class="level2"><a href="#AddingTransports">Adding Transports</a></li>
<li class="level2"><a href="#ServantBindings">Adding Servant Bindings</a></li>
<li class="level2"><a href="#StartingStopping">Starting and Stopping a Server</a></li>
<li class="level2"><a href="#ServerThreading">Server Threading</a></li>
</ul>
</li>
<li class="level1"><a href="#Sessions">Server-side Sessions</a><ul><li class="level2"><a href="#SessionObjects">Session Objects</a></li>
<li class="level2"><a href="#CustomUserData">Custom Request and Response Data</a></li>
<li class="level2"><a href="#SessionInformation">Session Information</a></li>
</ul>
</li>
<li class="level1"><a href="#AccessControl">Access Control</a></li>
<li class="level1"><a href="#ServerObjects">Server Objects</a></li>
</ul>
</div>
<div class="textblock"><p>On the server-side, <code><a class="el" href="class_r_c_f_1_1_rcf_server.html" title="Provides RCF server-side functionality. ">RCF::RcfServer</a></code> is the fundamental class responsible for dispatching remote calls from clients. A <code>RcfServer</code> contains one or more transports, on which it listens for remote calls from clients. A <code>RcfServer</code> also exposes one or more servant bindings, to which it dispatches remote calls that come in from clients.</p>
<p>A minimal example of a server was shown in the <a class="el" href="_tutorial.html">Tutorial</a>. First, a <code>RcfServer</code> is created with a TCP transport:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div></div><!-- fragment --><p> Then a servant binding is configured for the <code>I_PrintService</code> interface:</p>
<div class="fragment"><div class="line">    PrintService printService;</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService);</div></div><!-- fragment --><p> Finally, the server is started and begins to respond to remote calls from clients:</p>
<div class="fragment"><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --> <h1><a class="anchor" id="Configure"></a>
Configuring a Server</h1>
<h2><a class="anchor" id="AddingTransports"></a>
Adding Transports</h2>
<p>A <code>RcfServer</code> listens on one or more transports, for remote calls from clients. If you are setting up a server with only a single transport, you can supply the corresponding <code><a class="el" href="class_r_c_f_1_1_endpoint.html" title="Base class for all network endpoint types. ">RCF::Endpoint</a></code> parameter to the <code>RcfServer</code> constructor:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div></div><!-- fragment --><p> Alternatively, to configure multiple transports, you can use <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986" title="Adds another server transport layer to the RcfServer. ">RCF::RcfServer::addEndpoint()</a></code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(50002) );</div></div><!-- fragment --><p> To perform additional transport-related configuration, you can capture the return value from <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986" title="Adds another server transport layer to the RcfServer. ">RCF::RcfServer::addEndpoint()</a></code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line">        <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a>&amp; tcpTransport = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001));</div><div class="line">        tcpTransport.<a class="code" href="class_r_c_f_1_1_server_transport.html#af65cb430b56f71cacf0015eebae16afe">setConnectionLimit</a>(100);</div><div class="line">        tcpTransport.<a class="code" href="class_r_c_f_1_1_server_transport.html#ab6252f3ea4dbcabe7a5fb00df0107b52">setMaxIncomingMessageLength</a>(1024 * 1024);</div></div><!-- fragment --> <h2><a class="anchor" id="ServantBindings"></a>
Adding Servant Bindings</h2>
<p>Servant objects are responsible for the actual server functionality of your application. When a <code>RcfServer</code> receives a remote call request from a client, it uses the servant binding name specified in the request to locate the relevant servant binding, and then dispatches the remote call to the relevant function on that servant object.</p>
<p>Servant objects are always bound to a RCF interface. To create a servant binding, use <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f" title="Creates a servant binding, exposting the servant object to remote calls through the RCF interface Inte...">RCF::RcfServer::bind</a>&lt;&gt;()</code>. Each binding on the server is identified by its binding name, which is normally the runtime name of the RCF interface used in the binding.</p>
<p>So the following code:</p>
<div class="fragment"><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService);</div></div><!-- fragment --><p> , creates a servant binding with the servant binding name <code>"I_PrintService"</code>.</p>
<p>The servant binding name can also be set explicitly:</p>
<div class="fragment"><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService, <span class="stringliteral">&quot;CustomBindingName&quot;</span>);</div></div><!-- fragment --><p> Every remote call request from a client includes a servant binding name, which is used by the server to dispatch the remote call. The default servant binding name supplied by a RCF client is the runtime name of the RCF interface it is using. So the following client code:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> , makes a remote call which is dispatched by the server to a servant object with the servant binding name <code>"I_PrintService"</code>.</p>
<p>The client can also set the servant binding name explicitly:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001), <span class="stringliteral">&quot;CustomBindingName&quot;</span> );</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> , to dispatch the call to the nominated servant binding.</p>
<h2><a class="anchor" id="StartingStopping"></a>
Starting and Stopping a Server</h2>
<p>A <code>RcfServer</code> instance will not start dispatching remote calls until <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449" title="Starts the RcfServer. After starting, clients are able to connect to the server and execute remote ca...">RCF::RcfServer::start()</a></code> is called.</p>
<p>The server can be stopped manually by calling <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#acda4490f988f83af77528e3b5b5074f5" title="Stops the RcfServer. After stopping, clients are no longer able to connect to the server...">RCF::RcfServer::stop()</a></code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#acda4490f988f83af77528e3b5b5074f5">stop</a>();</div></div><!-- fragment --><p> The server will be stopped automatically if the <code>RcfServer</code> object goes out of scope.</p>
<h2><a class="anchor" id="ServerThreading"></a>
Server Threading</h2>
<p>By default, a <code>RcfServer</code> will use a single thread to dispatch calls across all its transports. This behavior can be modified by explicitly assigning a thread pool to the <code>RcfServer</code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">        RCF::ThreadPoolPtr threadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1, 5) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">setThreadPool</a>(threadPoolPtr);</div></div><!-- fragment --><p> <code><a class="el" href="class_r_c_f_1_1_thread_pool.html" title="Represents a server-side thread pool. ">RCF::ThreadPool</a></code> can be configured to use a fixed number of threads, or a varying number of threads depending on server load:</p>
<div class="fragment"><div class="line">            <span class="comment">// Thread pool with a fixed number of threads (5).</span></div><div class="line">            RCF::ThreadPoolPtr threadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(5) );</div><div class="line">            server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">setThreadPool</a>(threadPoolPtr);</div></div><!-- fragment --><div class="fragment"><div class="line">            <span class="comment">// Thread pool with a varying number of threads (1-25).</span></div><div class="line">            RCF::ThreadPoolPtr threadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1, 25) );</div><div class="line">            server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">setThreadPool</a>(threadPoolPtr);</div></div><!-- fragment --><p> A thread pool assigned to the <code>RcfServer</code> will be shared by all the transports of that <code>RcfServer</code>.</p>
<p>You can also use <code><a class="el" href="class_r_c_f_1_1_server_transport.html#a035886bcaf26a27f33ae201eb6410fee" title="Sets the thread pool that the server transport will use. ">RCF::ServerTransport::setThreadPool()</a></code> to assign thread pools to specific transports:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line"></div><div class="line">        RCF::ThreadPoolPtr tcpThreadPool( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1,5) );</div><div class="line">        <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; tcpTransport = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001));</div><div class="line">        tcpTransport.<a class="code" href="class_r_c_f_1_1_server_transport.html#a035886bcaf26a27f33ae201eb6410fee">setThreadPool</a>(tcpThreadPool);</div><div class="line"></div><div class="line">        RCF::ThreadPoolPtr pipeThreadPool( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1) );</div><div class="line">        <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; pipeTransport = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>(<a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;SvrPipe&quot;</span>));</div><div class="line">        pipeTransport.<a class="code" href="class_r_c_f_1_1_server_transport.html#a035886bcaf26a27f33ae201eb6410fee">setThreadPool</a>(pipeThreadPool);</div></div><!-- fragment --><h1><a class="anchor" id="Sessions"></a>
Server-side Sessions</h1>
<p>RCF creates a server-side <code><a class="el" href="class_r_c_f_1_1_rcf_session.html" title="Represents a server side session, associated with a client connection. ">RCF::RcfSession</a></code> object for each connection to the server. The <code>RcfSession</code> object has a lifetime that matches that of the client connection, and provides a mechanism for server-side code to persist state across remote calls on the same client connection.</p>
<p>From within a servant object executing a remote call, you can access the <code>RcfSession</code> by calling <code><a class="el" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2" title="Can only be called from within the server-side implementation of a remote call. Returns a reference t...">RCF::getCurrentRcfSession()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <h2><a class="anchor" id="SessionObjects"></a>
Session Objects</h2>
<p>Session objects are application C++ objects that are stored in the RCF session, and thus persisted across remote calls on the same connection. A typical use case for session objects is to associate application specific information with a connection. For example, application logic may require that after a client connects, the first thing it should do is call a <code>Login()</code> method. If the <code>Login()</code> method succeeds, the authenticated state of the connections needs to be persisted so that subsequent calls on the same connection can access it.</p>
<p>The following functions provide access to session objects:</p>
<ul>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a1632a13e375dcaabb28cc8df3e7926f3" title="Creates a session object. ">RCF::RcfSession::createSessionObject</a>&lt;&gt;()</code></li>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#ae0de2d50513e2e7c75c8363352430fa0" title="Retrieves a session object, and optionally creates it. ">RCF::RcfSession::getSessionObject</a>&lt;&gt;()</code></li>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a4ff730122e48a7fb538b26042bd85914" title="Queries for the existence of a session object. ">RCF::RcfSession::querySessionObject</a>&lt;&gt;()</code></li>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#afd7f54e613cc9a1f9892cf19a4d4e0b4" title="Deletes a session object. ">RCF::RcfSession::deleteSessionObject</a>&lt;&gt;()</code></li>
</ul>
<p>Session objects can be of arbitrary type, and their lifetime is controlled by the lifetime of the client connection. When the client connection is closed, any session objects associated with it are destroyed.</p>
<p>For an example of using session objects to store authentication state, see <a class="el" href="_serverside.html#AccessControl">Access Control</a>.</p>
<h2><a class="anchor" id="CustomUserData"></a>
Custom Request and Response Data</h2>
<p>As described in <a class="el" href="_clientside.html">Client-side Programming</a>, a remote call can have extra user data associated with it, apart from the parameters of the remote call. Both the remote call request and the remote call response can carry such data, and you can use the following <code>RcfSession</code> functions to access that data:</p>
<ul>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#ad3c4e6aced6599b1bb919e4a88666875" title="Gets application-specific data associated with the RCF request. ">RCF::RcfSession::getRequestUserData()</a></code></li>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a788d0d1b28905914c89ca64d4ada14e6" title="Sets application-specific data associated with the RCF request. ">RCF::RcfSession::setRequestUserData()</a></code></li>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a31f0b39ffb0031b345f2e0b083da6296" title="Gets application-specific data associated with the RCF response. ">RCF::RcfSession::getResponseUserData()</a></code></li>
<li><code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a2896d673a3c8bb40365b27acb728ad08" title="Sets application-specific data associated with the RCF response. ">RCF::RcfSession::setResponseUserData()</a></code></li>
</ul>
<h2><a class="anchor" id="SessionInformation"></a>
Session Information</h2>
<p>You can use <code>RcfSession</code> to find out a number of things about the current client connection, including:</p>
<ul>
<li>The transport being used:</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">    <a class="code" href="group___r_c_f.html#ga9d51f89404cea02f9102736f765ae06c">RCF::TransportType</a> transportType = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a52018609137ac446b54a70960e9c14ab">getTransportType</a>();</div></div><!-- fragment --><ul>
<li>The network address of the client:</li>
</ul>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="class_r_c_f_1_1_remote_address.html">RCF::RemoteAddress</a> &amp; clientAddress = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a475f3e53d1ff958e53c389215e56b470">getClientAddress</a>();</div><div class="line">    std::string strClientAddress = clientAddress.string();</div></div><!-- fragment --><ul>
<li>The current request header:</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_remote_call_info.html">RCF::RemoteCallInfo</a> request = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#acb3ffb2a4a43865b6fd26287f37643c0">getRemoteCallRequest</a>();</div></div><!-- fragment --><ul>
<li>How long the client has been connected:</li>
</ul>
<div class="fragment"><div class="line">    <span class="comment">// When the connection was established, as reported by CRT time() function.</span></div><div class="line">    time_t connectedAt = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1bbdcfa11c720bb9f94b4e894564dd7d">getConnectedAtTime</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Connection duration in seconds.</span></div><div class="line">    std::size_t connectionDurationS = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a136468580c2b1379b2b908a2a2c65cd8">getConnectionDuration</a>();</div></div><!-- fragment --><ul>
<li>How many calls have been made on this connection:</li>
</ul>
<div class="fragment"><div class="line">    std::size_t callsMade = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a86b112929677380eaf0cfb88a9f9087c">getRemoteCallCount</a>();</div></div><!-- fragment --><ul>
<li>How many bytes have been sent and received on this connection:</li>
</ul>
<div class="fragment"><div class="line">    std::uint64_t totalBytesReceived = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a93cefd1ccb229bb885343c09b00540c6">getTotalBytesReceived</a>();</div><div class="line">    std::uint64_t totalBytesSent = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a32276446bf1804f5e5d7ef2754049cec">getTotalBytesSent</a>();</div></div><!-- fragment --><ul>
<li>The transport protocol in use on the connection (see <a class="el" href="_transport_protocols.html">Transport Protocols</a>):</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="group___r_c_f.html#ga3f88ae1d5008805d5f75151296c2c9e8">RCF::TransportProtocol</a> protocol = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a282b5988695fbe26d63ccc6ec4f97970">getTransportProtocol</a>();</div></div><!-- fragment --><ul>
<li>The clients user name, if the client has been authenticated:</li>
</ul>
<div class="fragment"><div class="line">    std::string clientUserName = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div></div><!-- fragment --><ul>
<li>The SSL certificate the client has presented (if any):</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> clientCertPtr = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#ad743845ba9e8be362ff0d3fa1c91f10b">getClientCertificatePtr</a>();</div></div><!-- fragment --><p> For more information, see the reference documentation for <code><a class="el" href="class_r_c_f_1_1_rcf_session.html" title="Represents a server side session, associated with a client connection. ">RCF::RcfSession</a></code>.</p>
<h1><a class="anchor" id="AccessControl"></a>
Access Control</h1>
<p>RCF allows you to apply access controls to individual servant bindings on your server. The access control is implemented as a user-defined callback function, in which you can apply application-specific logic to determine whether a client connection should be allowed to access a particular servant binding.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> onPrintServiceAccess(<span class="keywordtype">int</span> methodId)</div><div class="line">{</div><div class="line">    <span class="comment">// Return true to allow access, and false to deny access.</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">    PrintService printService;</div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <a class="code" href="_rcf_fwd_8hpp.html#aa7df27075475c362966afe6407a3df07">RCF::ServerBindingPtr</a> bindingPtr = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService);</div><div class="line">    <span class="keyword">auto</span> accessControl = [&amp;](<span class="keywordtype">int</span> methodId) { <span class="keywordflow">return</span> onPrintServiceAccess(methodId); };</div><div class="line">    bindingPtr-&gt;setAccessControl(accessControl);</div><div class="line"></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> The access control callback will be invoked by the <code>RcfServer</code> each time a client tries to call a method on that servant binding.</p>
<p>From the access control callback you can inspect the current session and determine whether it should be granted access to the servant. Once authentication is granted, you will probably want to store the authentication state in a session object, so it can be easily reused on subsequent calls:</p>
<div class="fragment"><div class="line"><span class="comment">// App-specific authentication state.</span></div><div class="line"><span class="keyword">class </span>PrintServiceAuthenticationState</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PrintServiceAuthenticationState() : mAuthenticated(false)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span>            mAuthenticated;</div><div class="line">    std::string     mClientUsername;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Servant binding access control.</span></div><div class="line"><span class="keywordtype">bool</span> onPrintServiceAccess(<span class="keywordtype">int</span> methodId)</div><div class="line">{</div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">    PrintServiceAuthenticationState &amp; authState = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#ae0de2d50513e2e7c75c8363352430fa0">getSessionObject</a>&lt;PrintServiceAuthenticationState&gt;(<span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">if</span> (!authState.mAuthenticated)</div><div class="line">    {</div><div class="line">        <span class="comment">// Here we are checking that the client is using either NTLM or Kerberos.</span></div><div class="line">        <a class="code" href="group___r_c_f.html#ga3f88ae1d5008805d5f75151296c2c9e8">RCF::TransportProtocol</a> tp =  session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a282b5988695fbe26d63ccc6ec4f97970">getTransportProtocol</a>();</div><div class="line">        <span class="keywordflow">if</span> (tp == <a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a> || tp == <a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a34369316e7f91bdcfd657a4dad125efd">RCF::Tp_Kerberos</a>)</div><div class="line">        {</div><div class="line">            authState.mAuthenticated = <span class="keyword">true</span>;</div><div class="line">            authState.mClientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> authState.mAuthenticated;</div><div class="line">}</div></div><!-- fragment --><p> This example uses the access control callback to inspect the transport protocol the client is using, and uses that to determine the identity of the client.</p>
<p>In some situations you may want the client to provide extra authentication information, beyond what is available though the transport protocol. This typically means having the equivalent of a <code>Login()</code> method on the interface, that needs to be called before any other method on the interface. The access control callback can be used to verify that <code>Login()</code> is called before any other method:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// App-specific login info.</span></div><div class="line"><span class="keyword">class </span>LoginInfo</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp; ar) </div><div class="line">    {}</div><div class="line">};</div><div class="line"></div><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Login, const LoginInfo &amp;)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line"><span class="comment">// App-specific authentication state.</span></div><div class="line">class PrintServiceAuthenticationState</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PrintServiceAuthenticationState() : mAuthenticated(false)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    <span class="keywordtype">bool</span>            mAuthenticated;</div><div class="line">    std::string     mClientUsername;</div><div class="line">    LoginInfo       mLoginInfo;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Servant object.</span></div><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Login(<span class="keyword">const</span> LoginInfo &amp; loginInfo)</div><div class="line">    {</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">        PrintServiceAuthenticationState &amp; authState = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#ae0de2d50513e2e7c75c8363352430fa0">getSessionObject</a>&lt;PrintServiceAuthenticationState&gt;(<span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">if</span> (!authState.mAuthenticated)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___r_c_f.html#ga3f88ae1d5008805d5f75151296c2c9e8">RCF::TransportProtocol</a> tp =  session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a282b5988695fbe26d63ccc6ec4f97970">getTransportProtocol</a>();</div><div class="line">            <span class="keywordflow">if</span> (tp == <a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a> || tp == <a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a34369316e7f91bdcfd657a4dad125efd">RCF::Tp_Kerberos</a>)</div><div class="line">            {</div><div class="line">                authState.mAuthenticated = <span class="keyword">true</span>;</div><div class="line">                authState.mClientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line">                authState.mLoginInfo = loginInfo;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Servant binding access control.</span></div><div class="line"><span class="keywordtype">bool</span> onPrintServiceAccess(<span class="keywordtype">int</span> methodId)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (methodId == 0)</div><div class="line">    {</div><div class="line">        <span class="comment">// Calls to Login() are always allowed through.</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">        PrintServiceAuthenticationState &amp; authState = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#ae0de2d50513e2e7c75c8363352430fa0">getSessionObject</a>&lt;PrintServiceAuthenticationState&gt;(<span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">return</span> authState.mAuthenticated;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> In this case, the access control callback allows calls to <code>Login()</code> to go through, while for any other method on the <code>I_PrintService</code> interface, it checks for the existence of the authentication state that the <code>Login()</code> call creates.</p>
<p>The <code>Login()</code> method is identified in the access control callback by its method ID - in this case 0, as it is the first method on the interface. Method ID's are assigned in incremental order, from 0, so if for example <code>Login()</code> had been the third method on the interface, it would have had a method ID of 2.</p>
<h1><a class="anchor" id="ServerObjects"></a>
Server Objects</h1>
<p>Server objects are application specific objects that are created by your server-side code and stored in the <code>RcfServer</code>. Unlike session objects (which are stored in <code>RcfSession</code>), server objects persist and are accessible outside of the RCF session in which they were created. The lifetime of server objects is managed by <code><a class="el" href="class_r_c_f_1_1_rcf_server.html" title="Provides RCF server-side functionality. ">RCF::RcfServer</a></code>, using a garbage collection policy.</p>
<p>Server objects are manipulated with the following functions:</p>
<ul>
<li><a class="el" href="class_r_c_f_1_1_rcf_server.html#a98b2f4b6aee9df2c8daf22a047aad01d" title="Queries or creates a server object under the given key. If creating the object, the timeout value is ...">RCF::RcfServer::getServerObject&lt;&gt;()</a></li>
<li><a class="el" href="class_r_c_f_1_1_rcf_server.html#af2c3199a5f10051422f7675ea37fff04" title="Queries for a server object under the given key. Returns an empty std::shared_ptr if no object is fou...">RCF::RcfServer::queryServerObject&lt;&gt;()</a></li>
<li><a class="el" href="class_r_c_f_1_1_rcf_server.html#a14e08805f7726f3b5d74e615d1119d7d" title="Deletes the server object under the given key. ">RCF::RcfServer::deleteServerObject&lt;&gt;()</a></li>
</ul>
<p>Here is how we would create and update a server-wide session object for authenticated users:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintServiceSession</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    std::string mUsername;</div><div class="line">    std::uint32_t mMessagesPrinted = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;PrintServiceSession&gt; PrintServiceSessionPtr;</div><div class="line"></div><div class="line"><span class="comment">// Servant object.</span></div><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> &amp; server = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#acc2c410ba09956658ef8b04ede1236ff">getRcfServer</a>();</div><div class="line"></div><div class="line">        std::string clientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line">        <span class="keywordflow">if</span> ( clientUsername.size() &gt; 0 )</div><div class="line">        {</div><div class="line">            std::uint32_t gcTimeoutMs = 3600 * 1000;</div><div class="line"></div><div class="line">            PrintServiceSessionPtr printSessionPtr = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a98b2f4b6aee9df2c8daf22a047aad01d">getServerObject</a>&lt;PrintServiceSession&gt;(</div><div class="line">                clientUsername, </div><div class="line">                gcTimeoutMs);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ( printSessionPtr-&gt;mUsername.empty() )</div><div class="line">            {</div><div class="line">                printSessionPtr-&gt;mUsername = clientUsername;</div><div class="line">            }</div><div class="line">            ++printSessionPtr-&gt;mMessagesPrinted;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p> This code creates a <code>PrintServiceSession</code> object for each authenticated user. The <code>PrintServiceSession</code> object will be shared across all connections associated with that authenticated user. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
