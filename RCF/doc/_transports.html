
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_transports.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Transports </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Server">Transport Access</a></li>
<li class="level1"><a href="#Config">Transport Configuration</a><ul><li class="level2"><a href="#MaxMessageLength">Maximum Incoming Message Lengths</a></li>
<li class="level2"><a href="#ConnectionLimit">Connection Limits</a></li>
<li class="level2"><a href="#SystemPortSelection">System Port Selection</a></li>
<li class="level2"><a href="#Access">IP-based Access Rules</a></li>
<li class="level2"><a href="#IPv6">IPv4/IPv6</a></li>
<li class="level2"><a href="#Binding">Local Address Bindings for Clients</a></li>
<li class="level2"><a href="#SocketAccess">Socket Level Access</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementations">Transport Implementations</a><ul><li class="level2"><a href="#Tcp">TCP</a></li>
<li class="level2"><a href="#Udp">UDP</a><ul><li class="level3"><a href="#Multicast">Multicasting</a></li>
<li class="level3"><a href="#Broadcast">Broadcasting</a></li>
<li class="level3"><a href="#AddressSharing">Address Sharing</a></li>
<li class="level3"><a href="#ServerDiscovery">Server Discovery</a></li>
</ul>
</li>
<li class="level2"><a href="#Win32Pipes">Win32 Named Pipes</a></li>
<li class="level2"><a href="#Transports_LocalSockets">UNIX Domain Sockets</a></li>
<li class="level2"><a href="#HTTP">HTTP/HTTPS</a><ul><li class="level3"><a href="#Reverse_proxies">Reverse proxies</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Server"></a>
Transport Access</h1>
<p>Server and client transports are responsible for the actual transmission and reception of network messages. A <code>RcfServer</code> contains one or more server transports, while a client contains only a single client transport.</p>
<p>To access the server transports of a <code>RcfServer</code>, capture the return value of <code>RcfServer::addEndpoint()</code>:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line"></div><div class="line">    <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; serverTransportTcp = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( </div><div class="line">        <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; serverTransportUdp = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( </div><div class="line">        <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(50002) );</div><div class="line"></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> Alternatively, if the <code>RcfServer</code> only has a single server transport, you can access it by calling <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a4ce23dacf5070ffb1f1689dca8360fe9" title="Gets the first server transport of the RcfServer. ">RCF::RcfServer::getServerTransport()</a></code>:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; serverTransport = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a4ce23dacf5070ffb1f1689dca8360fe9">getServerTransport</a>();</div></div><!-- fragment --><p> On the client side, the client transport is availablable through <code><a class="el" href="class_r_c_f_1_1_client_stub.html#aed25109a12fb5eff358971769a9a772d" title="Returns a reference to the client transport of this ClientStub. ">RCF::ClientStub::getTransport()</a></code>:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    <a class="code" href="class_r_c_f_1_1_client_transport.html">RCF::ClientTransport</a> &amp; clientTransport = client.getClientStub().getTransport();</div></div><!-- fragment --><h1><a class="anchor" id="Config"></a>
Transport Configuration</h1>
<h2><a class="anchor" id="MaxMessageLength"></a>
Maximum Incoming Message Lengths</h2>
<p>For server-side transports, it is generally necessary to set an upper limit on the size of incoming network messages. Without an upper limit, it is possible for malformed requests to cause arbitrarily sized memory allocations on the server.</p>
<p>The maximum incoming message length setting of a RCF server transport defaults to 1 Mb, and can be changed by calling <code><a class="el" href="class_r_c_f_1_1_server_transport.html#ab6252f3ea4dbcabe7a5fb00df0107b52">RCF::ServerTransport::setMaxIncomingMessageLength()</a></code> :</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0) );</div><div class="line"></div><div class="line">    <span class="comment">// Set max message length to 5 Mb.</span></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a4ce23dacf5070ffb1f1689dca8360fe9">getServerTransport</a>().<a class="code" href="class_r_c_f_1_1_server_transport.html#ab6252f3ea4dbcabe7a5fb00df0107b52">setMaxIncomingMessageLength</a>(5*1024*1024);</div></div><!-- fragment --><p> Similarly, there is a maximum incoming message length setting for client transports. It defaults to 1 Mb and can be changed by calling <code><a class="el" href="class_r_c_f_1_1_client_transport.html#a11aa2132b74185fe2aa6b257fefb3bc4">RCF::ClientTransport::setMaxIncomingMessageLength()</a></code> :</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(123) );</div><div class="line"></div><div class="line">    <span class="comment">// Set max message length to 5 Mb.</span></div><div class="line">    client.getClientStub().getTransport().setMaxIncomingMessageLength(5*1024*1024);</div></div><!-- fragment --><p> As client transports only receive network messages from a peer they have connected to, the risk of malformed packets is not as great as for server transports.</p>
<p>It is possible to query a <code>RcfClient&lt;&gt;</code> for the sizes of the latest request and response messages sent:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        client.Echo(<span class="stringliteral">&quot;1234&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Retrieve request and response size of the previous call.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_client_transport.html">RCF::ClientTransport</a> &amp; transport = client.getClientStub().getTransport();</div><div class="line"></div><div class="line">        std::size_t requestSize = transport.<a class="code" href="class_r_c_f_1_1_client_transport.html#a638f3ea087147060ae9e05d96651dbb4">getLastRequestSize</a>();</div><div class="line">        std::size_t responseSize = transport.<a class="code" href="class_r_c_f_1_1_client_transport.html#a51f3de44c6252460cbbbdb2bba2a430b">getLastResponseSize</a>();</div></div><!-- fragment --><h2><a class="anchor" id="ConnectionLimit"></a>
Connection Limits</h2>
<p>To set the maximum number of simultaneous connections to a RCF server transport:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0) );</div><div class="line"></div><div class="line">    <span class="comment">// Allow at most 100 clients to be connected at any time.</span></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a4ce23dacf5070ffb1f1689dca8360fe9">getServerTransport</a>().<a class="code" href="class_r_c_f_1_1_server_transport.html#af65cb430b56f71cacf0015eebae16afe">setConnectionLimit</a>(100);</div></div><!-- fragment --><p> This setting is not relevant to the UDP server transport, as there is no concept of connections within the UDP protocol.</p>
<h2><a class="anchor" id="SystemPortSelection"></a>
System Port Selection</h2>
<p>For IP-based server transports, you can allow the local system to assign a server port number automatically, by specifying 0 as the port number. When the server starts, the system will find a free port and assign it to the server. The port number can subseqently be retrieved through <code><a class="el" href="class_r_c_f_1_1_ip_server_transport.html#a8039d39a935abdf24f5fade86574cac3" title="Returns the port number the IP-based server transport is listening on. ">RCF::IpServerTransport::getPort()</a></code>:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0) );</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> port = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a109e2e070599daafa3a50446b6336134">getIpServerTransport</a>().<a class="code" href="class_r_c_f_1_1_ip_server_transport.html#a8039d39a935abdf24f5fade86574cac3">getPort</a>();</div><div class="line">    RcfClient&lt;I_Echo&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div></div><!-- fragment --><h2><a class="anchor" id="Access"></a>
IP-based Access Rules</h2>
<p>For IP-based server transports, client access can be allowed or denied, based on the IP addresses of the clients.</p>
<p>To configure IP rules for allowing clients, use <a class="el" href="class_r_c_f_1_1_ip_server_transport.html#a4b976e1fda4673ffcbc45e1b7fdfe25e" title="Sets IP rules to allow connections from certain IP ranges. ">RCF::IpServerTransport::setAllowIps()</a>:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0) );</div><div class="line"></div><div class="line">    <a class="code" href="class_r_c_f_1_1_ip_server_transport.html">RCF::IpServerTransport</a> &amp; ipTransport = </div><div class="line">        <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_r_c_f_1_1_ip_server_transport.html">RCF::IpServerTransport</a> &amp;<span class="keyword">&gt;</span>(server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a4ce23dacf5070ffb1f1689dca8360fe9">getServerTransport</a>());</div><div class="line"></div><div class="line">    std::vector&lt;RCF::IpRule&gt; rules;</div><div class="line"></div><div class="line">    <span class="comment">// Match 11.22.33.* (24 significant bits).</span></div><div class="line">    rules.push_back( <a class="code" href="_ip_server_transport_8hpp.html#ab6e0237a93b9298bdc3e5edf19af0f1b">RCF::IpRule</a>( <a class="code" href="class_r_c_f_1_1_ip_address.html">RCF::IpAddress</a>(<span class="stringliteral">&quot;11.22.33.0&quot;</span>), 24) );</div><div class="line"></div><div class="line">    ipTransport.<a class="code" href="class_r_c_f_1_1_ip_server_transport.html#a4b976e1fda4673ffcbc45e1b7fdfe25e">setAllowIps</a>(rules);</div><div class="line"></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Access will be granted to clients connecting from IP addresses matching 11.22.33.* .</span></div><div class="line">    <span class="comment">// All other clients will be denied.</span></div></div><!-- fragment --><p> To configure IP rules for denying clients, use <a class="el" href="class_r_c_f_1_1_ip_server_transport.html#afc8fd7b87643f42bf9425ab458229227" title="Sets IP rules to deny connections from certain IP ranges. ">RCF::IpServerTransport::setDenyIps()</a>:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0) );</div><div class="line"></div><div class="line">    <a class="code" href="class_r_c_f_1_1_ip_server_transport.html">RCF::IpServerTransport</a> &amp; ipTransport = </div><div class="line">        <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_r_c_f_1_1_ip_server_transport.html">RCF::IpServerTransport</a> &amp;<span class="keyword">&gt;</span>(server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a4ce23dacf5070ffb1f1689dca8360fe9">getServerTransport</a>());</div><div class="line"></div><div class="line">    std::vector&lt;RCF::IpRule&gt; rules;</div><div class="line"></div><div class="line">    <span class="comment">// Match 11.*.*.* (8 significant bits).</span></div><div class="line">    rules.push_back( <a class="code" href="_ip_server_transport_8hpp.html#ab6e0237a93b9298bdc3e5edf19af0f1b">RCF::IpRule</a>( <a class="code" href="class_r_c_f_1_1_ip_address.html">RCF::IpAddress</a>(<span class="stringliteral">&quot;11.0.0.0&quot;</span>), 8) );</div><div class="line"></div><div class="line">    <span class="comment">// Match 12.22.*.* (16 significant bits).</span></div><div class="line">    rules.push_back( <a class="code" href="_ip_server_transport_8hpp.html#ab6e0237a93b9298bdc3e5edf19af0f1b">RCF::IpRule</a>( <a class="code" href="class_r_c_f_1_1_ip_address.html">RCF::IpAddress</a>(<span class="stringliteral">&quot;12.22.0.0&quot;</span>), 16) );</div><div class="line"></div><div class="line">    ipTransport.<a class="code" href="class_r_c_f_1_1_ip_server_transport.html#afc8fd7b87643f42bf9425ab458229227">setDenyIps</a>(rules);</div><div class="line"></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Access will be denied to clients connecting from IP addresses matching 11.*.*.*  and 12.22.*.* .</span></div><div class="line">    <span class="comment">// All other clients will be allowed.</span></div></div><!-- fragment --><h2><a class="anchor" id="IPv6"></a>
IPv4/IPv6</h2>
<p>RCF supports both IPv4 and IPv6. IPv6 support is enabled by default in RCF, but you can define <code>RCF_FEATURE_IPV6=0</code> to disable it (see <a class="el" href="_building_r_c_f.html">Building RCF</a>).</p>
<p>For example, to run a server and client over a loopback IPv4 connection:</p>
<div class="fragment"><div class="line">        <span class="comment">// Specifying an explicit IPv4 address to bind to.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Specifying an explicit IPv4 address to bind to.</span></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div></div><!-- fragment --><p> To run a server and client over a loopback IPv6 connection instead, specify <code>::1</code> instead of <code>127.0.0.1</code>:</p>
<div class="fragment"><div class="line">        <span class="comment">// Specifying an explicit IPv6 address to bind to.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;::1&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Specifying an explicit IPv6 address to bind to.</span></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;::1&quot;</span>, 50001) );</div></div><!-- fragment --><p> RCF uses the POSIX <code>getaddrinfo()</code> function to resolve IP addresses. <code>getaddrinfo()</code> can return either IPv4 or IPv6 addresses, depending on the configuration of the local system and network. So the following client will use either IPv4 or IPv6, depending on how the local system and network have been configured:</p>
<div class="fragment"><div class="line">        <span class="comment">// Will resolve to either IPv4 or IPv6, depending on what the system </span></div><div class="line">        <span class="comment">// resolves machine.domain to.</span></div><div class="line"></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;machine.domain&quot;</span>, 50001) );</div></div><!-- fragment --><p> You can force IPv4 or IPv6 resolution by using the <code><a class="el" href="class_r_c_f_1_1_ip_address_v4.html" title="Represents an IPv4 IP address. ">RCF::IpAddressV4</a></code> and <code><a class="el" href="class_r_c_f_1_1_ip_address_v6.html" title="Represents an IPv6 IP address. ">RCF::IpAddressV6</a></code> classes:</p>
<div class="fragment"><div class="line">        <span class="comment">// Force IPv4 address resolution.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_ip_address_v4.html">RCF::IpAddressV4</a> addr_4(<span class="stringliteral">&quot;machine.domain&quot;</span>, 50001);</div><div class="line">        RcfClient&lt;I_Echo&gt; client_4(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(addr_4) ));</div><div class="line"></div><div class="line">        <span class="comment">// Force IPv6 address resolution.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_ip_address_v6.html">RCF::IpAddressV6</a> addr_6(<span class="stringliteral">&quot;machine.domain&quot;</span>, 50001);</div><div class="line">        RcfClient&lt;I_Echo&gt; client_6(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(addr_6) ));</div></div><!-- fragment --><p> On machines with dual IPv4/IPv6 stacks, you will probably want your server to listen on both IPv4 and IPv6 addresses. To do this portably, you should listen on both <code>0.0.0.0</code> and <code>::0</code>:</p>
<div class="fragment"><div class="line">        <span class="comment">// Listen on port 50001, on both IPv4 and IPv6.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;::0&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> On some platforms, it is sufficient to listen only on <code>::0</code>, as the system will translate incoming IPv4 connections into IPv6 connections with a special class of IPv6 addresses.</p>
<h2><a class="anchor" id="Binding"></a>
Local Address Bindings for Clients</h2>
<p>When a <code>RcfClient&lt;&gt;</code> connects to a server using an IP-based transport, the default behavior is to allow the system to decide which local network interface and local port to use. In some circumstances, you may want to explicitly set the local network interface a client should bind to.</p>
<p>You can do so by calling <code><a class="el" href="class_r_c_f_1_1_ip_client_transport.html#ace7a4296bb4a0d058d9b4adae2e7b3a0" title="Sets the local IP address the client transport should bind to. ">RCF::IpClientTransport::setLocalIp()</a></code>, before connecting:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div><div class="line">        </div><div class="line">        <a class="code" href="class_r_c_f_1_1_ip_client_transport.html">RCF::IpClientTransport</a> &amp; ipTransport = </div><div class="line">            client.getClientStub().getIpTransport();</div><div class="line"></div><div class="line">        <span class="comment">// Force client to bind to a particular local network interface (127.0.0.1).</span></div><div class="line">        ipTransport.<a class="code" href="class_r_c_f_1_1_ip_client_transport.html#ace7a4296bb4a0d058d9b4adae2e7b3a0">setLocalIp</a>( <a class="code" href="class_r_c_f_1_1_ip_address.html">RCF::IpAddress</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 0) );</div><div class="line"></div><div class="line">        client.getClientStub().connect();</div></div><!-- fragment --><p> After a <code>RcfClient&lt;&gt;</code> has connected, you can determine which local network interface and port it is bound to, by calling <code><a class="el" href="class_r_c_f_1_1_ip_client_transport.html#a2d3d86e21381d09bd200589958eb44ef" title="Returns the local IP address the client transport is actually bound to. ">RCF::IpClientTransport::getAssignedLocalIp()</a></code>:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_ip_client_transport.html">RCF::IpClientTransport</a> &amp; ipTransport = </div><div class="line">            client.getClientStub().getIpTransport();</div><div class="line"></div><div class="line">        client.getClientStub().connect();</div><div class="line"></div><div class="line">        <span class="comment">// Find out which local network interface the client is bound to.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_ip_address.html">RCF::IpAddress</a> localIp = ipTransport.<a class="code" href="class_r_c_f_1_1_ip_client_transport.html#a2d3d86e21381d09bd200589958eb44ef">getAssignedLocalIp</a>();</div><div class="line">        std::string localInterface = localIp.getIp();</div><div class="line">        <span class="keywordtype">int</span> localPort = localIp.getPort();</div></div><!-- fragment --><h2><a class="anchor" id="SocketAccess"></a>
Socket Level Access</h2>
<p>RCF provides access to the underlying OS primitives, such as sockets and handles, of client and server transports. For example:</p>
<div class="fragment"><div class="line">        <span class="comment">// Client-side.</span></div><div class="line"></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div><div class="line">        client.getClientStub().connect();</div><div class="line"></div><div class="line">        RCF::TcpClientTransport &amp; tcpClientTransport = </div><div class="line">            <span class="keyword">dynamic_cast&lt;</span>RCF::TcpClientTransport &amp;<span class="keyword">&gt;</span>( </div><div class="line">                client.getClientStub().getTransport() );</div><div class="line"></div><div class="line">        <span class="comment">// Obtain client socket handle.</span></div><div class="line">        <span class="keywordtype">int</span> sock = tcpClientTransport.getNativeHandle();</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line">        <span class="comment">// Server-side.</span></div><div class="line"></div><div class="line">        RCF::NetworkSession &amp; networkSession = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>().getNetworkSession();</div><div class="line">        </div><div class="line">        RCF::TcpNetworkSession &amp; tcpNetworkSession = </div><div class="line">            <span class="keyword">dynamic_cast&lt;</span>RCF::TcpNetworkSession &amp;<span class="keyword">&gt;</span>(networkSession);</div><div class="line"></div><div class="line">        <span class="comment">// Obtain server socket handle.</span></div><div class="line">        <span class="keywordtype">int</span> sock = tcpNetworkSession.getNativeHandle();</div><div class="line"></div></div><!-- fragment --><p> This can be useful if you need to set custom socket options.</p>
<h1><a class="anchor" id="Implementations"></a>
Transport Implementations</h1>
<p>This sections covers the various transport types that are implemented in RCF.</p>
<h2><a class="anchor" id="Tcp"></a>
TCP</h2>
<p>TCP endpoints are represented in RCF by the <code><a class="el" href="class_r_c_f_1_1_tcp_endpoint.html" title="Represents a TCP endpoint. ">RCF::TcpEndpoint</a></code> class, constructed from an IP address and a port number.</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div></div><!-- fragment --><p> Server transports interpret the IP address as the local network interface to listen on. So for example <code>"0.0.0.0"</code> should be specified in order to listen on all available IPv4 network interfaces, and <code>"127.0.0.1"</code> should be specified to listen only on the loopback IPv4 interface. If no IP address is specified, <code>"127.0.0.1"</code> is assumed.</p>
<h2><a class="anchor" id="Udp"></a>
UDP</h2>
<p>Like <code><a class="el" href="class_r_c_f_1_1_tcp_endpoint.html" title="Represents a TCP endpoint. ">RCF::TcpEndpoint</a></code>, <code><a class="el" href="class_r_c_f_1_1_udp_endpoint.html" title="Represents a UDP endpoint. ">RCF::UdpEndpoint</a></code> is constructed from an IP address and a port.</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div></div><!-- fragment --><p> <code><a class="el" href="class_r_c_f_1_1_udp_endpoint.html" title="Represents a UDP endpoint. ">RCF::UdpEndpoint</a></code> also contains some extra functionality, to deal with multicasting and broadcasting.</p>
<h3><a class="anchor" id="Multicast"></a>
Multicasting</h3>
<p><code><a class="el" href="class_r_c_f_1_1_udp_endpoint.html" title="Represents a UDP endpoint. ">RCF::UdpEndpoint</a></code> can be configured to listen on a multicast IP address:</p>
<div class="fragment"><div class="line">        <span class="comment">// Listen on multicast address 232.5.5.5, on port 50001, on all network interfaces.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a> udpEndpoint(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001);</div><div class="line">        udpEndpoint.listenOnMulticast(<span class="stringliteral">&quot;232.5.5.5&quot;</span>);</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server(udpEndpoint);</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> Note that the server still needs to specify a local network interface to listen on.</p>
<p>To send multicast messages, specify a multicast IP address and port when creating the client:</p>
<div class="fragment"><div class="line">            RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;232.5.5.5&quot;</span>, 50001) );</div><div class="line">            client.Echo(<a class="code" href="group___r_c_f.html#ggaaca20c2301f5bc960ad6cbdc7da69683a64bfa0d2702bda52a323dd681b8d1ed2">RCF::Oneway</a>, <span class="stringliteral">&quot;ping&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="Broadcast"></a>
Broadcasting</h3>
<p>To send broadcast messages, specify a broadcast IP address and port:</p>
<div class="fragment"><div class="line">            RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;255.255.255.255&quot;</span>, 50001) );</div><div class="line">            client.Echo(<a class="code" href="group___r_c_f.html#ggaaca20c2301f5bc960ad6cbdc7da69683a64bfa0d2702bda52a323dd681b8d1ed2">RCF::Oneway</a>, <span class="stringliteral">&quot;ping&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="AddressSharing"></a>
Address Sharing</h3>
<p>RCF's UDP server transport can be configured to share its address binding, so that multiple <code>RcfServer</code>'s can listen on the same port of the same interface. This is enabled by default when listening on multicast addresses, but can also be enabled when listening on non-multicast addresses. This can be useful if multiple processes on the same machine need to listen to the same broadcasts:</p>
<div class="fragment"><div class="line">        EchoImpl echoImpl;</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a> udpEndpoint1(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001);</div><div class="line">        udpEndpoint1.enableSharedAddressBinding();</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server1(udpEndpoint1);</div><div class="line"></div><div class="line">        server1.bind&lt;I_Echo&gt;(echoImpl);</div><div class="line">        server1.start();</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a> udpEndpoint2(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001);</div><div class="line">        udpEndpoint2.enableSharedAddressBinding();</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server2(udpEndpoint2);</div><div class="line"></div><div class="line">        server2.bind&lt;I_Echo&gt;(echoImpl);</div><div class="line">        server2.start();</div><div class="line"></div><div class="line">        <span class="comment">// This broadcast message will be received by both servers.</span></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;255.255.255.255&quot;</span>, 50001) );</div><div class="line">        client.Echo(<a class="code" href="group___r_c_f.html#ggaaca20c2301f5bc960ad6cbdc7da69683a64bfa0d2702bda52a323dd681b8d1ed2">RCF::Oneway</a>, <span class="stringliteral">&quot;ping&quot;</span>);</div><div class="line"></div></div><!-- fragment --><h3><a class="anchor" id="ServerDiscovery"></a>
Server Discovery</h3>
<p>In situations where servers are started on dynamically assigned ports, multicasting and broadcasting can be a useful means of communicating server IP addresses and ports to clients. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Interface for broadcasting port number of a TCP server.</span></div><div class="line">RCF_BEGIN(I_Broadcast, <span class="stringliteral">&quot;I_Broadcast&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, ServerIsRunningOnPort, <span class="keywordtype">int</span>)</div><div class="line">RCF_END(I_Broadcast)</div><div class="line"></div><div class="line"><span class="comment">// Implementation class for receiving I_Broadcast messages.</span></div><div class="line">class BroadcastImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BroadcastImpl() : mPort()</div><div class="line">    {}</div><div class="line">    <span class="keywordtype">void</span> ServerIsRunningOnPort(<span class="keywordtype">int</span> port)</div><div class="line">    {</div><div class="line">        mPort = port;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">int</span> mPort;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// A server thread runs this function, to broadcast the server location once </span></div><div class="line"><span class="comment">// per second.</span></div><div class="line"><span class="keywordtype">void</span> broadcastThread(<span class="keywordtype">int</span> port, <span class="keyword">const</span> std::string &amp;multicastIp, <span class="keywordtype">int</span> multicastPort)</div><div class="line">{</div><div class="line">    RcfClient&lt;I_Broadcast&gt; client( </div><div class="line">        <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(multicastIp, multicastPort) );</div><div class="line"></div><div class="line">    client.getClientStub().setRemoteCallMode(<a class="code" href="group___r_c_f.html#ggaaca20c2301f5bc960ad6cbdc7da69683a64bfa0d2702bda52a323dd681b8d1ed2">RCF::Oneway</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Broadcast 1 message per second.</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        client.ServerIsRunningOnPort(port);</div><div class="line">        RCF::sleepMs(1000);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line">        <span class="comment">// ***** Server side ****</span></div><div class="line"></div><div class="line">        <span class="comment">// Start a server on a dynamically assigned port.</span></div><div class="line">        EchoImpl echoImpl;</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0));</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_Echo&gt;(echoImpl);</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Retrieve the port number.</span></div><div class="line">        <span class="keywordtype">int</span> port = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a109e2e070599daafa3a50446b6336134">getIpServerTransport</a>().<a class="code" href="class_r_c_f_1_1_ip_server_transport.html#a8039d39a935abdf24f5fade86574cac3">getPort</a>();        </div><div class="line"></div><div class="line">        <span class="comment">// Start broadcasting the port number.</span></div><div class="line">        RCF::ThreadPtr broadcastThreadPtr(<span class="keyword">new</span> RCF::Thread(</div><div class="line">            [=]() { broadcastThread(port, <span class="stringliteral">&quot;232.5.5.5&quot;</span>, 50001); }));</div><div class="line"></div><div class="line">        <span class="comment">// ***** Client side ****</span></div><div class="line"></div><div class="line">        <span class="comment">// Clients will listen for the broadcasts before doing anything else.</span></div><div class="line">        </div><div class="line">        <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a> udpEndpoint(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001);</div><div class="line">        udpEndpoint.listenOnMulticast(<span class="stringliteral">&quot;232.5.5.5&quot;</span>);</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> clientSideBroadcastListener(udpEndpoint);</div><div class="line"></div><div class="line">        BroadcastImpl broadcastImpl;</div><div class="line">        clientSideBroadcastListener.bind&lt;I_Broadcast&gt;(broadcastImpl);</div><div class="line"></div><div class="line">        clientSideBroadcastListener.start();</div><div class="line"></div><div class="line">        <span class="comment">// Wait for a broadcast message.</span></div><div class="line">        <span class="keywordflow">while</span> (!broadcastImpl.mPort)</div><div class="line">        {</div><div class="line">            RCF::sleepMs(1000);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Once the clients know the port number, they can connect.</span></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(broadcastImpl.mPort));</div><div class="line">        client.Echo(<span class="stringliteral">&quot;asdf&quot;</span>);</div><div class="line">    </div></div><!-- fragment --><p> Note that here we are actually using a multicast address to broadcast information to clients. If multicasting had been unavailable on this particular network, we could also have used an IP broadcast address instead of an IP multicast address.</p>
<h2><a class="anchor" id="Win32Pipes"></a>
Win32 Named Pipes</h2>
<p>RCF supports Win32 named pipe transports. <code><a class="el" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html" title="Represents a Win32 named pipe endpoint. Only available on Windows platforms. ">RCF::Win32NamedPipeEndpoint</a></code> takes one constructor parameter, which is the name of the named pipe, with or without the leading <code>\\.\pipe\</code> prefix.</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;PrintSvrPipe&quot;</span>) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;PrintSvrPipe&quot;</span>) );</div></div><!-- fragment --><p> An advantage of using Win32 named pipes, is that they allow easy authentication of clients. A server using a Win32 named pipe server transport can authenticate its clients through the <code><a class="el" href="class_r_c_f_1_1_win32_named_pipe_impersonator.html" title="Allows the server side of a Win32 named pipe to impersonate the client. ">RCF::Win32NamedPipeImpersonator</a></code> class, which uses the Windows API function <code>ImpersonateNamedPipeClient()</code> to impersonate the client:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)</div><div class="line">    RCF_METHOD_R1(std::<span class="keywordtype">string</span>, Echo, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_Echo)</div><div class="line"></div><div class="line">class EchoImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    std::string Echo(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        <span class="comment">// Impersonate client.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_win32_named_pipe_impersonator.html">RCF::Win32NamedPipeImpersonator</a> impersonator(RCF::getCurrentRcfSession());</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Client user name: &quot;</span> &lt;&lt; RCF::getMyUserName();</div><div class="line">        <span class="keywordflow">return</span> s;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> If we had used a TCP connection to <code>127.0.0.1</code> instead, we would have needed to enable Kerberos or NTLM authentication to securely determine the clients user name (see <a class="el" href="_transport_protocols.html">Transport protocols</a>).</p>
<h2><a class="anchor" id="Transports_LocalSockets"></a>
UNIX Domain Sockets</h2>
<p>UNIX domain sockets function analogously to Win32 named pipes, and allow efficient communication between servers and clients on the same machine. <code><a class="el" href="class_r_c_f_1_1_unix_local_endpoint.html" title="Represents a UNIX local socket endpoint. Only available on UNIX platforms. ">RCF::UnixLocalEndpoint</a></code> takes one parameter, which is the name of the UNIX domain socket. The name must be a valid filesystem path. For servers, the program must have sufficient privilege to create the given path, and the file must not already exist. For clients, the program must have sufficient privilege to access the given path.</p>
<p>Here is a simple example:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_unix_local_endpoint.html">RCF::UnixLocalEndpoint</a>(<span class="stringliteral">&quot;/home/xyz/MySocket&quot;</span>));</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_unix_local_endpoint.html">RCF::UnixLocalEndpoint</a>(<span class="stringliteral">&quot;/home/xyz/MySocket&quot;</span>));</div></div><!-- fragment --> <h2><a class="anchor" id="HTTP"></a>
HTTP/HTTPS</h2>
<p>RCF supports tunneling remote calls over the <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> and <a href="http://en.wikipedia.org/wiki/HTTP_Secure">HTTPS</a> protocols. In particular, remote calls can be directed through HTTP and HTTPS proxies.</p>
<p>HTTPS is essentially the HTTP protocol layered on top of the SSL protocol. As such, configuration of the SSL aspects of HTTPS, is done in the same way as for the SSL transport protocol (see <a class="el" href="_transport_protocols.html">Transport protocols</a>).</p>
<h3>Server-side</h3>
<p>To setup a server with an HTTP endpoint, use <code><a class="el" href="class_r_c_f_1_1_http_endpoint.html" title="Represents a HTTP endpoint. ">RCF::HttpEndpoint</a></code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_http_endpoint.html">RCF::HttpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 80) );</div><div class="line">        PrintService printService;</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService);</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> Similarly, for an HTTPS endpoint, use <code><a class="el" href="class_r_c_f_1_1_https_endpoint.html" title="Represents a HTTPS endpoint. ">RCF::HttpsEndpoint</a></code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_https_endpoint.html">RCF::HttpsEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 443) );</div><div class="line">        PrintService printService;</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService);</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a5e870568919107b46301743d7de39b83">setCertificate</a>( <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a>( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pfx_certificate.html">RCF::PfxCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\serverCert.p12&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;CertificateName&quot;</span>) ) );</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><h3>Client-side</h3>
<p>Client side configuration is similar, using <code><a class="el" href="class_r_c_f_1_1_http_endpoint.html" title="Represents a HTTP endpoint. ">RCF::HttpEndpoint</a></code> for a HTTP client:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_http_endpoint.html">RCF::HttpEndpoint</a>(<span class="stringliteral">&quot;printsvr.acme.com&quot;</span>, 80) );</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> , and <code><a class="el" href="class_r_c_f_1_1_https_endpoint.html" title="Represents a HTTPS endpoint. ">RCF::HttpsEndpoint</a></code> for a HTTPS client:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_https_endpoint.html">RCF::HttpsEndpoint</a>(<span class="stringliteral">&quot;printsvr.acme.com&quot;</span>, 443) );</div><div class="line">        client.getClientStub().setCertificateValidationCallback(&amp;schannelValidate);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> Finally, to direct remote calls through a HTTP or HTTPS proxy, use the <code><a class="el" href="class_r_c_f_1_1_client_stub.html#ac347fc281307ef5506ceefdaec5eab19" title="Sets the HTTP proxy to use for HTTP/HTTPS connections. ">RCF::ClientStub::setHttpProxy()</a></code> and <code><a class="el" href="class_r_c_f_1_1_client_stub.html#ae37efe5cf75d7eefd6c7b88c1e0a924d" title="Sets the HTTP proxy port to use for HTTP/HTTPS connections. ">RCF::ClientStub::setHttpProxyPort()</a></code> functions:</p>
<div class="fragment"><div class="line">            client.getClientStub().setHttpProxy(<span class="stringliteral">&quot;web-proxy.acme.com&quot;</span>);</div><div class="line">            client.getClientStub().setHttpProxyPort(8080);</div><div class="line">            client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="Reverse_proxies"></a>
Reverse proxies</h3>
<p>HTTP reverse proxies are common on the Internet, and are used to provide functionality such as load balancing and SSL offloading for back-end HTTP servers.</p>
<p>Reverse proxies are generally transparent to the client and destination servers. You can place a reverse proxy between a RCF client and a server, and this provides an out-of-the-box mechanism for distributing load across a set of RCF servers.</p>
<p>In load-balancing scenarios, you may want a RCF client to continue sending requests to the same back-end server that it initially connects to. To accomplish this, you will need to use a reverse proxy with support for session affinity. Session affinity is normally implemented by the reverse proxy, by inserting a special HTTP cookie in the initial HTTP response of the communication stream. The RCF client will then automatically include this cookie on subsequent requests, allowing the reverse proxy to route subsequent requests through to the same back-end server.</p>
<p>If you have multiple RCF client connections, you can configure them to connect to the same back-end server, by retrieving the HTTP cookies from the first connection and subsequently applying them to the other connections (see <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a05c0fb1bf52fa5804fc2820b2c66e501" title="Sets a list of cookies to include in HTTP requests to the server. ">RCF::ClientStub::setHttpCookies()</a></code>).</p>
<p>Another reverse proxying feature you can utilize with RCF is SSL offloading. With SSL offloading , the RCF client connects using a HTTPS connection, but the HTTPS connection is decrypted by the reverse proxy, and the decrypted HTTP stream is forwarded on to the back-end server. This allows secure communication between the client and the back-end server, with the reverse proxy assuming the load of SSL encryption/decryption. This also has the advantage of centralizing certificate configuration, from multiple back-end servers, to the reverse proxy server.</p>
<p>RCF has been tested with the following reverse proxies:</p>
<ul>
<li><a href="https://www.iis.net/downloads/microsoft/application-request-routing">IIS ARR</a></li>
<li><a href="https://www.nginx.com/">nginx</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
