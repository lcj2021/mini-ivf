
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_transport_protocols.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Transport Protocols </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#NTLM">NTLM</a></li>
<li class="level1"><a href="#Kerberos">Kerberos</a></li>
<li class="level1"><a href="#Negotiate">Negotiate</a></li>
<li class="level1"><a href="#SSL">SSL</a><ul><li class="level2"><a href="#Schannel">Schannel</a></li>
<li class="level2"><a href="#OpenSSL">OpenSSL</a></li>
</ul>
</li>
<li class="level1"><a href="#Compression">Compression</a></li>
</ul>
</div>
<div class="textblock"><p>Transport protocols are used to transform the data passing over a transport. RCF uses transport protocols to provide authentication, encryption and compression for remote calls.</p>
<p>RCF currently supports NTLM, Kerberos, Negotiate and SSL transport protocols. NTLM, Kerberos and Negotiate are only supported on Windows platforms, while SSL is supported on all platforms.</p>
<p>In addition, RCF also supports Zlib-based compression of remote calls.</p>
<p>Transport protocols are configured on a client connection by calling <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a3e1cbd34dc1006000319356737008a63" title="Sets the transport protocol. ">RCF::ClientStub::setTransportProtocol()</a></code>:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);</div></div><!-- fragment --><p> From within the server session of a client connection, you can call <code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a282b5988695fbe26d63ccc6ec4f97970" title="Gets the transport protocol in use on this RcfSession. ">RCF::RcfSession::getTransportProtocol()</a></code> to determine the transport prococol the client is using:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">        <a class="code" href="group___r_c_f.html#ga3f88ae1d5008805d5f75151296c2c9e8">RCF::TransportProtocol</a> tp = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a282b5988695fbe26d63ccc6ec4f97970">getTransportProtocol</a>();</div></div><!-- fragment --> <h1><a class="anchor" id="NTLM"></a>
NTLM</h1>
<p>To configure NTLM on a client connection:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div><div class="line">    client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);</div><div class="line">    client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> On the server-side, you can determine the Windows user name of the client, and impersonate them:</p>
<div class="fragment"><div class="line">        std::string clientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_sspi_impersonator.html">RCF::SspiImpersonator</a> impersonator(session);</div><div class="line">        <span class="comment">// We are now impersonating the client, until impersonator goes out of scope.</span></div><div class="line">        <span class="comment">// ...</span></div></div><!-- fragment --><h1><a class="anchor" id="Kerberos"></a>
Kerberos</h1>
<p>To configure Kerberos on a client connection:</p>
<div class="fragment"><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a34369316e7f91bdcfd657a4dad125efd">RCF::Tp_Kerberos</a>);</div><div class="line">        client.getClientStub().setKerberosSpn(<span class="stringliteral">&quot;Domain\\ServerAccount&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> Notice that the client needs to call <code>ClientStub::setKerberosSpn()</code> to specify the username it expects the server to be running under. This is known as the SPN (Service Principal Name) of the server, and is used in the Kerberos protocol to implement mutual authentication. If the server is not running under this account, the connection will fail.</p>
<p>On the server-side, you can determine the Windows username of the client, and impersonate them:</p>
<div class="fragment"><div class="line">        std::string clientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_sspi_impersonator.html">RCF::SspiImpersonator</a> impersonator(session);</div><div class="line">        <span class="comment">// We are now impersonating the client, until impersonator goes out of scope.</span></div><div class="line">        <span class="comment">// ...</span></div></div><!-- fragment --><h1><a class="anchor" id="Negotiate"></a>
Negotiate</h1>
<p>Negotiate is a negotiation protocol between the NTLM and Kerberos protocols. It will resolve to Kerberos if possible, and otherwise fall back to NTLM.</p>
<p>To configure Negotiate on a client connection:</p>
<div class="fragment"><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a3f11a72710a1277236322e1ecc34c418">RCF::Tp_Negotiate</a>);</div><div class="line">        client.getClientStub().setKerberosSpn(<span class="stringliteral">&quot;Domain\\ServerAccount&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> As with the Kerberos transport protocol, you need to supply a SPN for the server.</p>
<p>On the server-side, you can determine the Windows username of the client, and impersonate them:</p>
<div class="fragment"><div class="line">        std::string clientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_sspi_impersonator.html">RCF::SspiImpersonator</a> impersonator(session);</div><div class="line">        <span class="comment">// We are now impersonating the client, until impersonator goes out of scope.</span></div><div class="line">        <span class="comment">// ...</span></div></div><!-- fragment --><h1><a class="anchor" id="SSL"></a>
SSL</h1>
<p>RCF offers two SSL transport protocol implementations. One is based on the cross-platform OpenSSL library, and the other is based on the Windows-only Schannel package.</p>
<p>OpenSSL support is only available if <code>RCF_USE_OPENSSL</code> has been defined.</p>
<p>Schannel support is only available in Windows builds, and does not require any defines.</p>
<p>If you define <code>RCF_USE_OPENSSL</code> in a Windows build, RCF will use OpenSSL rather than Schannel. Should you want to use Schannel, despite defining <code>RCF_USE_OPENSSL</code>, you can set the SSL implementation for individual servers and clients using the <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#af60d05d5e41fd7ed16ed3efe5f7c703b" title="Sets the SSL implementation in use by this RcfServer (OpenSSL or Schannel). ">RCF::RcfServer::setSslImplementation()</a></code> and <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a01372c4b051eee29e6a4c6da97510b51" title="Sets the SSL implementation in use by this ClientStub (OpenSSL or Schannel). ">RCF::ClientStub::setSslImplementation()</a></code> functions, or set it for the entire RCF runtime using the <code><a class="el" href="class_r_c_f_1_1_globals.html#ac73afd1c6fe86c3982e8a9c4f62b4976" title="Sets the default SSL implementation to use (OpenSSL or Schannel). The default is Schannel on Windows...">RCF::Globals::setDefaultSslImplementation()</a></code> function.</p>
<p>The SSL protocol uses certificates to authenticate servers to clients (and optionally clients to servers). Certificate and certificate validation functionality is handled differently by the two SSL transport protocol implementations, as described below.</p>
<h2><a class="anchor" id="Schannel"></a>
Schannel</h2>
<p>To configure a server to accept SSL connections, you need to provide a server certificate. RCF provides the <code><a class="el" href="class_r_c_f_1_1_pfx_certificate.html" title="Use this class to load a certificate from .pfx format. Only applicable to Schannel. ">RCF::PfxCertificate</a></code> class, to load certificates from .pfx and .p12 files:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> serverCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pfx_certificate.html">RCF::PfxCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\serverCert.p12&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;CertificateName&quot;</span>) );</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a5e870568919107b46301743d7de39b83">setCertificate</a>(serverCertPtr);</div></div><!-- fragment --><p> RCF also provides the <code><a class="el" href="class_r_c_f_1_1_store_certificate.html" title="Represents a certificate in a Windows certificate store. ">RCF::StoreCertificate</a></code> class, to load certificates from Windows certificate stores:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> serverCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_store_certificate.html">RCF::StoreCertificate</a>(</div><div class="line">            <a class="code" href="group___r_c_f.html#ggad63a8841e9cbf54719dabecb687b0b75a03e5da5b7f708485a9839b17f081a249">RCF::Cl_LocalMachine</a>,</div><div class="line">            <a class="code" href="group___r_c_f.html#ggad0cb73ef13b805181770256c34ebacd5a2e5a6d956ca586c6080a3fca272a9420">RCF::Cs_My</a>,</div><div class="line">            <span class="stringliteral">&quot;CertificateName&quot;</span>) );</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a5e870568919107b46301743d7de39b83">setCertificate</a>(serverCertPtr);</div></div><!-- fragment --><p> On the client, you need to provide a means of validating the certificate presented by the server. There are several ways of doing this. You can let the Schannel package apply its own internal validation logic, which will defer to the locally installed certificate authorities:</p>
<div class="fragment"><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa8b10df13dfa056f392358446881f316">RCF::Tp_Ssl</a>);</div><div class="line">        client.getClientStub().setEnableSchannelCertificateValidation(<span class="stringliteral">&quot;CertificateName&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> You can also provide a particular certificate authority yourself, which will be used to validate the server certificate:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> caCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pfx_certificate.html">RCF::PfxCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\clientCaCertificate.p12&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;CaCertificatename&quot;</span>));</div><div class="line"></div><div class="line">        client.getClientStub().setCaCertificate(caCertPtr);</div></div><!-- fragment --><p> You can also write your own custom certificate validation logic:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> schannelValidateCert(<a class="code" href="class_r_c_f_1_1_certificate.html">RCF::Certificate</a> * pCert)</div><div class="line">{</div><div class="line">    <a class="code" href="class_r_c_f_1_1_win32_certificate.html">RCF::Win32Certificate</a> * pWin32Cert = <span class="keyword">static_cast&lt;</span><a class="code" href="class_r_c_f_1_1_win32_certificate.html">RCF::Win32Certificate</a> *<span class="keyword">&gt;</span>(pCert);</div><div class="line">    <span class="keywordflow">if</span> (pWin32Cert)</div><div class="line">    {</div><div class="line">        RCF::tstring certName = pWin32Cert-&gt;<a class="code" href="class_r_c_f_1_1_win32_certificate.html#aa95df40d3c6c0c8cc5b5e334edb1ec4c">getCertificateName</a>();</div><div class="line">        RCF::tstring issuerName = pWin32Cert-&gt;<a class="code" href="class_r_c_f_1_1_win32_certificate.html#a554ab0f6548e920a78bf47cb377330c3">getIssuerName</a>();</div><div class="line"></div><div class="line">        PCCERT_CONTEXT pContext = pWin32Cert-&gt;getWin32Context();</div><div class="line"></div><div class="line">        <span class="comment">// Custom code to inspect and validate certificate.</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return true if the certificate is considered valid. Otherwise, return false,</span></div><div class="line">    <span class="comment">// or throw an exception.</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">        client.getClientStub().setCertificateValidationCallback(&amp;schannelValidateCert);</div></div><!-- fragment --><p> RCF clients can also be configured to present a certificate to the server:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> clientCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pfx_certificate.html">RCF::PfxCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\clientCert.p12&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;CertificateName&quot;</span>) );</div><div class="line"></div><div class="line">        client.getClientStub().setCertificate(clientCertPtr);</div></div><!-- fragment --><p> Server-side certificate validation is done in the same way as client-side certificate validation, but using the <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a26480ecccf19f9753c6c53c858e8852d" title="Sets the certificate name to match against, when validating a client certificate. Only applicable to ...">RCF::RcfServer::setEnableSchannelCertificateValidation()</a></code>, <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a6fc0948f012a9ad35d409c99f0623887" title="Sets the certificate validation callback, used to validate client certificates. ">RCF::RcfServer::setCertificateValidationCallback()</a></code>, and <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#ab2919c0b64ddb069f1493bfe8238e46f" title="Sets the certificate authority certificate to use when validating certificates from a HTTPS client...">RCF::RcfServer::setCaCertificate()</a></code> functions.</p>
<h2><a class="anchor" id="OpenSSL"></a>
OpenSSL</h2>
<p>When using the OpenSSL-based SSL transport protocol, certificates need to be loaded from .pem files, using the <code><a class="el" href="class_r_c_f_1_1_pem_certificate.html" title="Use this class to load a certificate from .pem format. Only applicable to OpenSSL. ">RCF::PemCertificate</a></code> class. Here is an example of providing a server certificate:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> serverCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pem_certificate.html">RCF::PemCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\serverCert.pem&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>) );</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a5e870568919107b46301743d7de39b83">setCertificate</a>(serverCertPtr);</div></div><!-- fragment --><p> The client can validate the server certificate in two ways. It can provide a certificate authority certificate:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> caCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pem_certificate.html">RCF::PemCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\clientCaCertificate.pem&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>));</div><div class="line"></div><div class="line">        client.getClientStub().setCaCertificate(caCertPtr);</div></div><!-- fragment --><p> , or it can provide custom validation logic in a callback function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> opensslValidateCert(<a class="code" href="class_r_c_f_1_1_certificate.html">RCF::Certificate</a> * pCert)</div><div class="line">{</div><div class="line">    <a class="code" href="class_r_c_f_1_1_x509_certificate.html">RCF::X509Certificate</a> * pX509Cert = <span class="keyword">static_cast&lt;</span><a class="code" href="class_r_c_f_1_1_x509_certificate.html">RCF::X509Certificate</a> *<span class="keyword">&gt;</span>(pCert);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (pX509Cert)</div><div class="line">    {</div><div class="line">        std::string certName = pX509Cert-&gt;<a class="code" href="class_r_c_f_1_1_x509_certificate.html#a21cc9b878ab934d23ab5a361d9de9bd5">getCertificateName</a>();</div><div class="line">        std::string issuerName = pX509Cert-&gt;<a class="code" href="class_r_c_f_1_1_x509_certificate.html#ae28b4b4759ea09ff2d05fa34087400c1">getIssuerName</a>();</div><div class="line"></div><div class="line">        X509 * pX509 = pX509Cert-&gt;getX509();</div><div class="line"></div><div class="line">        <span class="comment">// Custom code to inspect and validate certificate.</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return true if valid, false if not.</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">        client.getClientStub().setCertificateValidationCallback(&amp;opensslValidateCert);</div></div><!-- fragment --><p> The client can also provide a certificate of its own, to present to the server:</p>
<div class="fragment"><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> clientCertPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pem_certificate.html">RCF::PemCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\clientCert.pem&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;password&quot;</span>) );</div><div class="line"></div><div class="line">        client.getClientStub().setCertificate(clientCertPtr);</div></div><!-- fragment --><p> Server-side certificate validation is done in the same way as client-side certificate validation, but using the <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a6fc0948f012a9ad35d409c99f0623887" title="Sets the certificate validation callback, used to validate client certificates. ">RCF::RcfServer::setCertificateValidationCallback()</a></code>, and <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#ab2919c0b64ddb069f1493bfe8238e46f" title="Sets the certificate authority certificate to use when validating certificates from a HTTPS client...">RCF::RcfServer::setCaCertificate()</a></code> functions.</p>
<h1><a class="anchor" id="Compression"></a>
Compression</h1>
<p>RCF supports transport-level compression of remote calls. To build RCF with support for compression, define <code>RCF_USE_ZLIB</code> (see <a class="el" href="_building_r_c_f.html">Building RCF</a>).</p>
<p>Compression is configured independently of other transport protocols, using <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a22f4147ef26b2b117999e1ce7066d953" title="Sets whether compression is enabled for this connection. ">RCF::ClientStub::setEnableCompression()</a></code>:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div><div class="line">        client.getClientStub().setEnableCompression(<span class="keyword">true</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> RCF applies the compression stage before the transport protocol stage. For example, if you configure compression and NTLM on the same connection:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);      </div><div class="line">        client.getClientStub().setEnableCompression(<span class="keyword">true</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> , the remote call data will be compressed first, before being encrypted and sent across the wire. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
