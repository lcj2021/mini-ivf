
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_versioning.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Versioning </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#InterfaceVersioning">Interface Versioning</a><ul><li class="level2"><a href="#Methods">Adding or Removing Methods</a></li>
<li class="level2"><a href="#Parameters">Adding or Removing Parameters</a></li>
<li class="level2"><a href="#Renaming">Renaming Interfaces</a></li>
</ul>
</li>
<li class="level1"><a href="#ArchiveVersioning">Archive Versioning</a></li>
<li class="level1"><a href="#RuntimeVersioning">Runtime Versioning</a><ul><li class="level2"><a href="#CustomVersionNegotiation">Custom Version Negotiation</a></li>
</ul>
</li>
<li class="level1"><a href="#ProtobufVersioning">Protocol Buffers</a></li>
</ul>
</div>
<div class="textblock"><p>RCF provides robust versioning support, allowing you to upgrade distributed components without breaking runtime compatibility with previously deployed components.</p>
<p>If you write components which only communicate with peer components of the same version, you won't need to worry about versioning. For instance, if all your components are built from the same codebase and deployed together, versioning won't be an issue.</p>
<p>However, if for example you have clients which need to communicate with servers that were built from an older version of the same codebase, and have already been deployed, then you will need to be aware of how RCF deals with versioning.</p>
<p>Unlike other RPC systems you may have encountered, RCF is designed to be versioning-friendly. The data contract between a client and a server is essentially defined by the following:</p>
<ul>
<li>The methods on the RCF interface.</li>
<li>The order and type of the parameters of those methods.</li>
<li>The serialization functions of the parameters.</li>
</ul>
<p>RCF allows you considerable scope to evolve all these aspects of your data contract, without invalidating your existing data contract.</p>
<h1><a class="anchor" id="InterfaceVersioning"></a>
Interface Versioning</h1>
<h2><a class="anchor" id="Methods"></a>
Adding or Removing Methods</h2>
<p>Each method in an RCF interface has a method ID associated with it, which is used by clients to identify that particular method. The first method on an interface has a method ID of 0, the next one a method ID of 1, and so on.</p>
<p>Inserting a method at the beginning, or in the middle, of an RCF interface, changes the existing method ID's and hence breaks compatibility with existing clients and servers. To preserve compatibility, new methods need to be added at the end of the RCF interface:</p>
<div class="fragment"><div class="line"><span class="comment">// Version 1</span></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, subtract, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Version 2.</span></div><div class="line"></div><div class="line"><span class="comment">// * Clients compiled against this interface will be able to call add() and </span></div><div class="line"><span class="comment">//   subtract() on servers compiled against the old interface.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// * Servers compiled against this interface will be able to take add() and </span></div><div class="line"><span class="comment">//   subtract() calls from clients compiled against the old interface.</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, subtract, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, multiply, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --><p> Removing methods can be done as well, as long as a place holder is left in the interface, in order to preserve the method ID's of the remaining methods in the interface.</p>
<div class="fragment"><div class="line"><span class="comment">// Version 1</span></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, subtract, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Version 2. </span></div><div class="line"></div><div class="line"><span class="comment">// * Clients compiled against this interface will be able to call subtract() </span></div><div class="line"><span class="comment">//   on servers compiled against the old interface.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// * Servers compiled against this interface will be able to take subtract()</span></div><div class="line"><span class="comment">//   calls from clients compiled against the old interface (but not add() calls).</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_PLACEHOLDER()</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, subtract, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --><h2><a class="anchor" id="Parameters"></a>
Adding or Removing Parameters</h2>
<p>Parameters can be added to a method, or removed from a method, without breaking compatibility. RCF servers and clients ignore any extra (redundant) parameters that are passed in a remote call, and if an expected parameter is not supplied, it is default initialized.</p>
<div class="fragment"><div class="line"><span class="comment">// Version 1</span></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Version 2</span></div><div class="line"></div><div class="line"><span class="comment">// * Clients compiled against this interface will be able to call add() </span></div><div class="line"><span class="comment">//   on servers compiled against the old interface (the server will ignore</span></div><div class="line"><span class="comment">//   the third parameter).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// * Servers compiled against this interface will be able to take add()</span></div><div class="line"><span class="comment">//   calls from clients compiled against the old interface (the third parameter</span></div><div class="line"><span class="comment">//   will be default initialized to zero).</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R3(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --><p> Likewise, parameters can be removed:</p>
<div class="fragment"><div class="line"><span class="comment">// Version 1</span></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Version 2</span></div><div class="line"></div><div class="line"><span class="comment">// * Clients compiled against this interface will be able to call add() </span></div><div class="line"><span class="comment">//   on servers compiled against the old interface (the server will assume the</span></div><div class="line"><span class="comment">//   second parameter is zero).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// * Servers compiled against this interface will be able to take add()</span></div><div class="line"><span class="comment">//   calls from clients compiled against the old interface (the second parameter</span></div><div class="line"><span class="comment">//   from the client will be ignored).</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R1(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --><p> Note that RCF marshals in-parameters and out-parameters in the order that they appear in the <code>RCF_METHOD_XX()</code> declaration. Any added (or removed) parameters must be the last to be marshalled, otherwise compatibility will be broken.</p>
<h2><a class="anchor" id="Renaming"></a>
Renaming Interfaces</h2>
<p>RCF interfaces are identified by their runtime name, as specified in the second parameter of the <code>RCF_BEGIN()</code> macro. As long as this name is preserved, the compile time name of the interface can be changed, without breaking compatibility.</p>
<div class="fragment"><div class="line"><span class="comment">// Version 1</span></div><div class="line">RCF_BEGIN(I_Calculator, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_Calculator)</div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Version 2</span></div><div class="line"></div><div class="line"><span class="comment">// * Clients compiled against this interface will be able to call add() </span></div><div class="line"><span class="comment">//   on servers compiled against the old interface.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// * Servers compiled against this interface will be able to take add()</span></div><div class="line"><span class="comment">//   calls from clients compiled against the old interface.</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_CalculatorService, <span class="stringliteral">&quot;I_Calculator&quot;</span>)</div><div class="line">    RCF_METHOD_R2(<span class="keywordtype">double</span>, add, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>)</div><div class="line">RCF_END(I_CalculatorService)</div></div><!-- fragment --><h1><a class="anchor" id="ArchiveVersioning"></a>
Archive Versioning</h1>
<p>The application-specific data types passed in a remote call, are likely to change over time. As those data types change, their serialization functions will change as well. To assist applications in maintaining backwards compatibility for serialization code, RCF provides an archive version number concept.</p>
<p>The archive version number is passed from client to server on every remote call, and is zero by default. To implement versioning, your application is expected to manage the archive version, essentially updating it whenever a breaking change is made to serialization code.</p>
<p>To set the archive version number, call <code><a class="el" href="_version_8hpp.html#a93f3cfe224b97643d9de169f4c28ba52" title="Sets the RCF archive version number. Applies to all RCF clients and servers within the current proces...">RCF::setArchiveVersion()</a></code> before creating any servers or clients.</p>
<p>Alternatively, you can set the archive version number for individual clients and servers by calling <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a6d5c0464fb9038da43e512410385ef40" title="Sets the archive version of this ClientStub. ">RCF::ClientStub::setArchiveVersion()</a></code> and <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a5c7483f68d8b378095ecc2122b31edd3" title="Sets the archive version number used by this RcfServer. ">RCF::RcfServer::setArchiveVersion()</a></code>.</p>
<p>When a client connects to a server, an automatic version negotiation step takes place, to ensure that the connection uses the greatest archive version number that both components support.</p>
<p>The archive version number is intended to be used by serialization code. From within a serialization function you can retrieve the archive version number in use, by calling <code><a class="el" href="class_s_f_1_1_archive.html#ab57895175bdee4ff0b1e2018a06c520b" title="Gets the archive version associated with this archive. ">SF::Archive::getArchiveVersion()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp; ar, MyClass &amp; m)</div><div class="line">{</div><div class="line">    std::uint32_t archiveVersion = ar.<a class="code" href="class_s_f_1_1_archive.html#ab57895175bdee4ff0b1e2018a06c520b">getArchiveVersion</a>();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p> The serialization code can then use the value of the archive version number to determine which members to serialize.</p>
<p>For example, assume that the first version of your application contains this code:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>X</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> mA = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp; ar)</div><div class="line">    {</div><div class="line">        ar &amp; mA;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)</div><div class="line">    RCF_METHOD_R1(X, Echo, const X &amp;)</div><div class="line">RCF_END(I_Echo)</div><div class="line"></div><div class="line">class EchoImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    X Echo(<span class="keyword">const</span> X &amp; x) </div><div class="line">    { </div><div class="line">        <span class="keywordflow">return</span> x; </div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">//--------------------------------------------------------------------------</span></div><div class="line">    <span class="comment">// Accepting calls from other processes...</span></div><div class="line">    EchoImpl echo;</div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_Echo&gt;(echo);</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    <span class="comment">//--------------------------------------------------------------------------</span></div><div class="line">    <span class="comment">// ... or making calls to other processes.</span></div><div class="line">    RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50002) );</div><div class="line"></div><div class="line">    X x1;</div><div class="line">    X x2;</div><div class="line">    x2 = client.Echo(x1);</div></div><!-- fragment --><p> Once this version has been released, a new version is prepared, with a new member added to the <code>X</code> class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>X</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> mA = 0;</div><div class="line">    <span class="keywordtype">int</span> mB = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp; ar)</div><div class="line">    {</div><div class="line">        <span class="comment">// Retrieve archive version, to determine which members to serialize.</span></div><div class="line">        std::uint32_t version = ar.<a class="code" href="class_s_f_1_1_archive.html#ab57895175bdee4ff0b1e2018a06c520b">getArchiveVersion</a>();</div><div class="line"></div><div class="line">        ar &amp; mA;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (version &gt;= 1)</div><div class="line">        {</div><div class="line">            ar &amp; mB;</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>EchoImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    X Echo(<span class="keyword">const</span> X &amp; x) { <span class="keywordflow">return</span> x; }</div><div class="line">};</div></div><!-- fragment --><p> Notice that the serialization code of <code>X</code> now uses the archive version number to determine whether it should serialize the new <code>mB</code> member.</p>
<p>With these changes, new servers are able to process calls from both old and new clients, and new clients are able to call either old or new servers:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// The specified archive version should be the latest archive version this process supports.</span></div><div class="line">    <a class="code" href="_version_8hpp.html#a93f3cfe224b97643d9de169f4c28ba52">RCF::setArchiveVersion</a>(1);</div><div class="line"></div><div class="line">    <span class="comment">//--------------------------------------------------------------------------</span></div><div class="line">    <span class="comment">// Accepting calls from other processes...</span></div><div class="line"></div><div class="line">    <span class="comment">// This server can take calls from either new or old clients. Archive version</span></div><div class="line">    <span class="comment">// will be 0 when old clients call in, and 1 when new clients call in.</span></div><div class="line">    EchoImpl echo;</div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_Echo&gt;(echo);</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    <span class="comment">//--------------------------------------------------------------------------</span></div><div class="line">    <span class="comment">// ... or making calls to other processes.</span></div><div class="line"></div><div class="line">    <span class="comment">// This client can call either new or old servers.</span></div><div class="line">    RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50002) );</div><div class="line"></div><div class="line">    X x1;</div><div class="line">    X x2;</div><div class="line"></div><div class="line">    <span class="comment">// If the server on port 50002 is old, this call will have archive version set to 0.</span></div><div class="line">    <span class="comment">// If the server on port 50002 is new, this call will have archive version set to 1.</span></div><div class="line">    x2 = client.Echo(x1);</div></div><!-- fragment --><h1><a class="anchor" id="RuntimeVersioning"></a>
Runtime Versioning</h1>
<p>RCF maintains runtime compatibility with itself, for previous RCF releases dating back to and including RCF 2.0. Runtime compatibilty with RCF releases older than 2.0 is not guaranteed.</p>
<p>To implement runtime compatibility between RCF releases, RCF maintains a runtime version number, which is incremented for each RCF release. The runtime version number is passed in the request header for each remote call, and allows older and newer RCF releases to interoperate.</p>
<p>RCF's automatic client-server version negotiation handles runtime versioning, as well as archive versioning. In most circumstances, you won't need to know about runtime version numbers. You can mix and match RCF releases, and at runtime, an appropriate runtime version is negotiated for each client-server connection.</p>
<h2><a class="anchor" id="CustomVersionNegotiation"></a>
Custom Version Negotiation</h2>
<p>In some situations, the client may already know the runtime version and archive version of the server it is about to call, in which case it can disable automatic versioning and set the version numbers explicitly:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_Echo&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <span class="comment">// Turn off automatic version negotiation.</span></div><div class="line">    client.getClientStub().setAutoVersioning(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Client setting version numbers explicitly to match RCF 2.0, with archive version 2.</span></div><div class="line">    client.getClientStub().setRuntimeVersion(10); <span class="comment">// RCF 2.0</span></div><div class="line">    client.getClientStub().setArchiveVersion(2);</div><div class="line"></div><div class="line">    <span class="comment">// If the server doesn&#39;t support the requested version numbers, an exception will be thrown.</span></div><div class="line">    X x1;</div><div class="line">    X x2 = client.Echo(x1);</div></div><!-- fragment --><p> Automatic version negotiation is not supported for one-way calls. In particular, the one-way calls made by a publisher to its subscribers, are not automatically versioned. If you have subscribers with varying runtime and archive version numbers, the publisher will need to explicitly set version numbers on the publishing <code>RcfClient&lt;&gt;</code> object, to match that of the oldest anticipated subscriber:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line">    </div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="class_r_c_f_1_1_publisher.html">RCF::Publisher&lt;I_PrintService&gt;</a> PrintServicePublisher;</div><div class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt; PrintServicePublisher &gt; PrintServicePublisherPtr;</div><div class="line">    PrintServicePublisherPtr pubPtr = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3897d6a968fc0d9c4c04ae2d3c1911f8">createPublisher</a>&lt;I_PrintService&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Client setting version numbers explicitly to support older subscribers.</span></div><div class="line">    pubPtr-&gt;publish().getClientStub().setRuntimeVersion(10); <span class="comment">// RCF runtime version 10 (RCF 2.0).</span></div><div class="line">    pubPtr-&gt;publish().getClientStub().setArchiveVersion(5); <span class="comment">// Application archive version 5.</span></div></div><!-- fragment --><p> For reference, here is a table of runtime version numbers for each RCF release.</p>
<table class="doxtable">
<tr>
<th>RCF release </th><th>Runtime version number  </th></tr>
<tr>
<td>2.0 </td><td>10 </td></tr>
<tr>
<td>2.1 </td><td>11 </td></tr>
<tr>
<td>2.2 </td><td>12 </td></tr>
<tr>
<td>3.0 </td><td>13 </td></tr>
</table>
<h1><a class="anchor" id="ProtobufVersioning"></a>
Protocol Buffers</h1>
<p>For applications with backwards compatibility requirements and short or continuous release cycles, archive versioning can become difficult to manage. Each increment of the archive version number involves adding new execution paths to serialization functions, and may over time lead to complicated serialization code.</p>
<p>RCF also supports <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>, which provides an alternative approach to versioning. Rather than manually writing serialization code for C++ objects, Protocol Buffers can be used to generate C++ classes with built-in serialization code, which deals automatically with versioning differences (see <a class="el" href="_external_serialization.html#Protobufs">Protocol Buffers</a>). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
