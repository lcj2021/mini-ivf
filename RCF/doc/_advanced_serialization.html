
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_advanced_serialization.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced Serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Polymorphic">Polymorphic Serialization</a></li>
<li class="level1"><a href="#Pointers">Pointer Tracking</a></li>
<li class="level1"><a href="#Interchangeable">Interchangeable Types</a></li>
<li class="level1"><a href="#Unicode">Unicode Strings</a></li>
</ul>
</div>
<div class="textblock"><p>Serializing generic C++ objects is a complex task in and of itself. This section describes some of the more advanced features of RCF's internal serialization framework.</p>
<h1><a class="anchor" id="Polymorphic"></a>
Polymorphic Serialization</h1>
<p>RCF will automatically detect and serialize polymorphic pointers and references, as fully derived types. However, to do this, RCF needs to be configured with two pieces of information about the polymorphic type being serialized. First, RCF needs a runtime identifier string for the derived type. Second, it needs to know which base types the derived type will be serialized through.</p>
<p>Here is an example of a polymorphic class hierarchy, with associated serialization functions:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~A() </div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp;ar)</div><div class="line">    {</div><div class="line">        ar &amp; mA;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> mA = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp;ar)</div><div class="line">    {</div><div class="line">        SF::serializeParent&lt;A&gt;(ar, *<span class="keyword">this</span>);</div><div class="line">        ar &amp; mB;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> mB = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>C : <span class="keyword">public</span> B</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp;ar)</div><div class="line">    {</div><div class="line">        SF::serializeParent&lt;B&gt;(ar, *<span class="keyword">this</span>);</div><div class="line">        ar &amp; mC;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> mC = 0;</div><div class="line">};</div></div><!-- fragment --><p> Note that <code><a class="el" href="_serialize_parent_8hpp.html#aa7d34330e49d5fcff85faca344c05c41">SF::serializeParent()</a></code> is used to invoke base class serialization code. If you try to serialize the parent class directly, e.g. by calling <code>ar &amp; static_cast&lt;A&amp;&gt;(*this)</code>, RCF will detect that the parent class is actually a derived class, and will try to serialize the derived class once again.</p>
<p>Now consider the following RCF interface, which utilizes a class <code>X</code> containing polymorphic <code>A</code> pointers:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>X</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    </div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp;ar)</div><div class="line">    {</div><div class="line">        ar &amp; mAPtr;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::shared_ptr&lt;A&gt; mAPtr;</div><div class="line">};</div><div class="line"></div><div class="line">RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)</div><div class="line">    RCF_METHOD_R1(X, Echo, X)</div><div class="line">RCF_END(I_Echo)</div></div><!-- fragment --><p> In order to polymorphically serialize <code>X::mAPtr</code>, we need to do two things:</p>
<ul>
<li>Use <code>SF::registerType()</code> to set runtime identifiers for the <code>B</code> and <code>C</code> classes. The runtime identifiers will be included in serialized archives when <code>B</code> and <code>C</code> objects are serialized, and will allow the deserialization code to construct objects of the appropriate type.</li>
<li>Use <code>SF::registerBaseAndDerived()</code> to specify which base classes the derived classes will be serialized through.</li>
</ul>
<p>In our case, the following code is sufficient:</p>
<div class="fragment"><div class="line">    <span class="comment">// Register polymorphic types.</span></div><div class="line">    SF::registerType&lt;B&gt;(<span class="stringliteral">&quot;B&quot;</span>);</div><div class="line">    SF::registerType&lt;C&gt;(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Register base/derived relationships for polymorphic types.</span></div><div class="line">    SF::registerBaseAndDerived&lt;A, B&gt;();</div><div class="line">    SF::registerBaseAndDerived&lt;A, C&gt;();</div></div><!-- fragment --><p> This code needs to be executed at the startup of both the client and the server. Once executed, we can make remote calls to the <code>Echo()</code> method and the polymorphic <code>A</code> pointers will be serialized and deserialized, as fully derived types.</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_Echo&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port)));</div><div class="line"></div><div class="line">        X x1;</div><div class="line">        x1.mAPtr.reset( <span class="keyword">new</span> B() );</div><div class="line">        X x2 = client.Echo(x1);</div><div class="line"></div><div class="line">        x1.mAPtr.reset( <span class="keyword">new</span> C() );</div><div class="line">        x2 = client.Echo(x1);</div></div><!-- fragment --><h1><a class="anchor" id="Pointers"></a>
Pointer Tracking</h1>
<p>If you serialize a pointer to the same object twice, RCF will by default serialize the entire object twice. This means that when the pointers are deserialized, they will point to two distinct objects. In most applications this is usually not an issue. However, some applications may want the deserialization code to instead create two pointers to the same object.</p>
<p>RCF supports this through a pointer tracking concept, where an object is serialized in its entirety, only once, regardless of how many pointers to it are serialized. Upon deserialization, only a single object is created, and multiple pointers can then be deserialized, pointing to the same object.</p>
<p>To demonstrate pointer tracking, here is an an <code>I_Echo</code> interface with an <code>Echo()</code> function that takes a pair of <code>std::shared_ptr&lt;&gt;</code> objects:</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> </div><div class="line">        std::pair&lt; std::shared_ptr&lt;std::string&gt;, std::shared_ptr&lt;std::string&gt; &gt;</div><div class="line">        PointerPair;</div><div class="line"></div><div class="line">    RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)</div><div class="line">        RCF_METHOD_R1(PointerPair, Echo, PointerPair)</div><div class="line">    RCF_END(I_Echo2)</div></div><!-- fragment --><p> Here is client-side code to call <code>Echo()</code>:</p>
<div class="fragment"><div class="line">        std::shared_ptr&lt;std::string&gt; ptr1( <span class="keyword">new</span> std::string(<span class="stringliteral">&quot;one&quot;</span>));</div><div class="line">        std::shared_ptr&lt;std::string&gt; ptr2( ptr1 );</div><div class="line"></div><div class="line">        PointerPair ret = client.Echo( std::make_pair(ptr1, ptr2));</div></div><!-- fragment --><p> If we make a call to <code>Echo()</code> with a pair of <code>shared_ptr&lt;&gt;</code> objects pointing to the same <code>std::string</code>, we'll find that the returned pair points to two distinct <code>std::string</code> objects. To get them to point to the same <code>std::string</code>, we can enable pointer tracking, on the client-side:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_Echo&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port)));</div><div class="line"></div><div class="line">        client.getClientStub().setEnableSfPointerTracking(<span class="keyword">true</span>);</div></div><!-- fragment --><p> , and also on the server-side:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EchoImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T Echo(T t)</div><div class="line">    {</div><div class="line">        <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>().<a class="code" href="class_r_c_f_1_1_rcf_session.html#af1f494c63c71c3ba17a25da03abb7dda">setEnableSfPointerTracking</a>(<span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">return</span> t;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The two returned <code>shared_ptr&lt;&gt;</code> objects will now point to the same instance.</p>
<p>Pointer tracking is a relatively expensive feature and should only be enabled if your application requires it. Pointer tracking requires the serialization framework to track all pointers and values that are being serialized to and from an archive, resulting in significant performance overhead.</p>
<h1><a class="anchor" id="Interchangeable"></a>
Interchangeable Types</h1>
<p>Serialization and deserialization tend to be performed symmetrically, in the sense that serialization code writes a type <code>T</code> to an archive, and deserialization code reads the same type <code>T</code> from the archive.</p>
<p>Symmetry is not a requirement for serialization, however. If two classes <code>A</code> and <code>B</code> have serialization functions that serialize the same number and type of members, then you can serialize an <code>A</code> instance to an archive and deserialize a <code>B</code> instance from the archive. Essentially, the classes <code>A</code> and <code>B</code> are interchangeable from a serialization point of view.</p>
<p>RCF guarantees serialization interchangeability for a number of types. For example, for any type <code>T</code>, <code>T</code> and <code>T *</code> are interchangeable. So you can serialize a pointer, and then deserialize it as a value:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// Serializing a pointer.</span></div><div class="line">    <span class="keywordtype">int</span> * pn = <span class="keyword">new</span> int(5);</div><div class="line">    std::ostringstream ostr;</div><div class="line">    <a class="code" href="class_s_f_1_1_o_binary_stream.html">SF::OBinaryStream</a>(ostr) &lt;&lt; pn;</div><div class="line">    <span class="keyword">delete</span> pn;</div><div class="line"></div><div class="line">    <span class="comment">// Deserializing a value.</span></div><div class="line">    <span class="keywordtype">int</span> m = 0;</div><div class="line">    std::istringstream istr(ostr.str());</div><div class="line">    <a class="code" href="class_s_f_1_1_i_binary_stream.html">SF::IBinaryStream</a>(istr) &gt;&gt; m;</div><div class="line">    <span class="comment">// m is now 5</span></div><div class="line"></div></div><!-- fragment --><p> Furthermore, smart pointers are interchangeable with native pointers, so you can serialize a <code>std::shared_ptr&lt;T&gt;</code> and then deserialize it into a value <code>T</code>. Here is another example:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// Client-side implementation of X, using int.</span></div><div class="line"><span class="keyword">class </span>X</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> n;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp; ar, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div><div class="line">    {</div><div class="line">        ar &amp; n;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line"><span class="comment">// Server-side implementation of X, using shared_ptr&lt;int&gt;.</span></div><div class="line"><span class="keyword">class </span>X</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    std::shared_ptr&lt;int&gt; spn;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a> &amp; ar)</div><div class="line">    {</div><div class="line">        ar &amp; spn;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Even with different X implementations, client and server can still </span></div><div class="line"><span class="comment">// interact through this interface.</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_EchoX,<span class="stringliteral">&quot;I_EchoX&quot;</span>)</div><div class="line">RCF_METHOD_R1(X, Echo, X)</div><div class="line">RCF_END(I_EchoX)</div></div><!-- fragment --><p> A significant consequence of this is that if you start out using <code>T</code>, <code>T*</code>, <code>std::shared_ptr&lt;T&gt;</code>, <code>std::unique_ptr&lt;T&gt;</code> or some other smart pointer in your RCF interface, you can always change it at a later point in time, without breaking backward compatibility.</p>
<p>The following are classes of types that RCF guarantees to be interchangeable:</p>
<ul>
<li><code>T</code>, <code>T *</code>, <code>std::unique_ptr&lt;T&gt;</code>, <code>std::shared_ptr&lt;T&gt;</code>, <code>boost::scoped_ptr&lt;T&gt;</code>, <code>boost::shared_ptr&lt;T&gt;</code></li>
<li>Integral types of equivalent size, e.g. <code>unsigned int</code> and <code>int</code></li>
<li>C++98 enums and 32 bit integral types</li>
<li>STL containers of <code>T</code>, where <code>T</code> is non-primitive</li>
<li>STL containers of <code>T</code> (except <code>std::vector&lt;&gt;</code> and <code>std::basic_string&lt;&gt;</code>), where <code>T</code> is primitive</li>
<li><code>std::vector&lt;T&gt;</code> and <code>std::basic_string&lt;T&gt;</code>, where <code>T</code> is primitive</li>
<li><code>std::string</code>, <code>std::vector&lt;char&gt;</code>, and <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code></li>
</ul>
<h1><a class="anchor" id="Unicode"></a>
Unicode Strings</h1>
<p>Serialization of <code>std::wstring</code> objects presents some portability issues, as different platforms have different definitions of <code>wchar_t</code> and different Unicode encodings for <code>std::wstring</code>.</p>
<p>RCF resolves this by converting <code>std::wstring</code> objects to UTF-8 before serializing.</p>
<ul>
<li>On platforms with 16 bit <code>wchar_t</code>, RCF assumes that any <code>std::wstring</code> passed to it, is encoded in UTF-16, and converts between UTF-16 and UTF-8.</li>
<li>On platforms with 32 bit <code>wchar_t</code>, RCF assumes that any <code>std::wstring</code> passed to it is encoded in UTF-32, and converts between UTF-32 and UTF-8.</li>
</ul>
<p>If your application is sending or receiving <code>std::wstring</code> objects, encoded in something other than the assumed UTF-16 or UTF-32 encodings, you should be aware that cross-platform portability may be affected. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
