
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_async_remote_calls.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Asynchronous Remote Calls </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ClientSideAsync">Asynchronous Invocation</a></li>
<li class="level1"><a href="#ServerSideAsync">Asynchronous Dispatching</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ClientSideAsync"></a>
Asynchronous Invocation</h1>
<p>Asynchronous invocation of remote calls allow you to initate remote calls on one thread, and have them complete asynchronously on another thread.</p>
<p>Asynchronous invocation is implemented in RCF using the <code><a class="el" href="class_r_c_f_1_1_future.html" title="Provides the ability for remote calls to be executed asynchronously. ">RCF::Future</a>&lt;&gt;</code> class. If a <code><a class="el" href="class_r_c_f_1_1_future.html" title="Provides the ability for remote calls to be executed asynchronously. ">RCF::Future</a>&lt;&gt;</code> object is supplied as the return value, or as one of the parameters, of a remote call, the remote call is performed asynchronously.</p>
<p>For example, given this RCF interface:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Returns number of characters printed.</span></div><div class="line">    RCF_METHOD_R1(<span class="keywordtype">int</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line"></div><div class="line">RCF_END(I_PrintService)</div></div><!-- fragment --><p> , an asynchronous call would be initiated by the following code:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div><div class="line">    <a class="code" href="class_r_c_f_1_1_future.html">RCF::Future&lt;int&gt;</a> fRet = client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> The thread that executes this code will return immediately. The code can subsequently poll for completion:</p>
<div class="fragment"><div class="line">    <span class="comment">// Poll until remote call completes.</span></div><div class="line">    <span class="keywordflow">while</span> (!fRet.<a class="code" href="class_r_c_f_1_1_future.html#a6062726e0e67d49b66ad4f1f94461ff7">ready</a>())</div><div class="line">    {</div><div class="line">        RCF::sleepMs(500);</div><div class="line">    }</div></div><!-- fragment --><p> , or it can wait for completion:</p>
<div class="fragment"><div class="line">    <span class="comment">// Wait for remote call to complete.</span></div><div class="line">    fRet.<a class="code" href="class_r_c_f_1_1_future.html#aa0f8a62c86da3d61bc1160885d302b97">wait</a>();</div></div><!-- fragment --><p> Once the call is complete, the return values can be recovered from the relevant <code>Future&lt;&gt;</code> instances:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> charsPrinted = *fRet;</div></div><!-- fragment --><p> If the call resulted in an error, the error will be thrown when the <code>Future&lt;&gt;</code> instance is dereferenced, as above. Alternatively, the error can be retrieved by calling <code><a class="el" href="class_r_c_f_1_1_future.html" title="Provides the ability for remote calls to be executed asynchronously. ">RCF::Future</a>&lt;&gt;::getAsyncException()</code>:</p>
<div class="fragment"><div class="line">    std::unique_ptr&lt;RCF::Exception&gt; ePtr = fRet.getAsyncException();</div></div><!-- fragment --><p> Instead of polling or waiting, the thread that initiates an asynchronous remote call can provide a completion callback that will be called by the RCF runtime, on a background thread, when the call completes:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::shared_ptr&lt; RcfClient&lt;I_PrintService&gt; &gt; PrintServicePtr;</div><div class="line"><span class="keywordtype">void</span> onCallCompleted(PrintServicePtr client, <a class="code" href="class_r_c_f_1_1_future.html">RCF::Future&lt;int&gt;</a> fRet)</div><div class="line">{</div><div class="line">    std::unique_ptr&lt;RCF::Exception&gt; ePtr = fRet.getAsyncException();</div><div class="line">    <span class="keywordflow">if</span> (ePtr.get())</div><div class="line">    {</div><div class="line">        <span class="comment">// Deal with any exception.</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> charsPrinted = *fRet;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_future.html">RCF::Future&lt;int&gt;</a> fRet;</div><div class="line">        PrintServicePtr client( <span class="keyword">new</span> RcfClient&lt;I_PrintService&gt;(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port)) );</div><div class="line">        <span class="keyword">auto</span> onCompletion = [=]() { onCallCompleted(client, fRet);  };</div><div class="line">        fRet = client-&gt;Print( </div><div class="line">            RCF::AsyncTwoway(onCompletion), </div><div class="line">            <span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> Notice that the <code>Future&lt;&gt;</code> arguments are passed as arguments to the completion callback function. <code>Future&lt;&gt;</code> objects are internally reference counted, and can be copied freely, while still referring to the same underlying value.</p>
<p>An asynchronous call that is in progress, can be canceled by disconnecting the client:</p>
<div class="fragment"><div class="line">    client.getClientStub().disconnect();</div></div><!-- fragment --><p> If a <code>RcfClient</code> is destroyed while an asynchronous call is in progress, the connection is automatically disconnected and any asynchronous operations are canceled.</p>
<h1><a class="anchor" id="ServerSideAsync"></a>
Asynchronous Dispatching</h1>
<p>On the server-side, RCF will normally dispatch a remote call on the same server thread that reads the remote call request from the transport. Asynchronous dispatching allows you to instead transfer the remote call over to other threads, freeing up the RCF server thread to proceed with other remote calls.</p>
<p>The <code><a class="el" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext</a>&lt;&gt;</code> class is used to capture the server-side context of a remote call. <code><a class="el" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext</a>&lt;&gt;</code> objects can be copied into queues and stored for later execution on arbitrary application threads.</p>
<p><code><a class="el" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext</a>&lt;&gt;</code> objects are created from within the corresponding servant implementation method. For comparison, here is a non-asynchronously dispatched <code>Print()</code> method:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Returns number of characters printed.</span></div><div class="line">    RCF_METHOD_R1(<span class="keywordtype">int</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line"></div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line">class PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) s.length();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> To instead dispatch the call asynchronously, create a <code><a class="el" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext</a>&lt;&gt;</code> object in <code>Print()</code>, with template parameters corresponding to the method signature:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext&lt;int, const std::string&amp;&gt;</a> PrintContext;</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        <span class="comment">// Capture current remote call context.</span></div><div class="line">        PrintContext printContext(RCF::getCurrentRcfSession());</div><div class="line"></div><div class="line">        <span class="comment">// Start a new thread to dispatch the remote call.</span></div><div class="line">        std::thread printAsyncThread([=]() { printAsync(printContext); });</div><div class="line">        printAsyncThread.detach();</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> printAsync(PrintContext printContext)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> std::string &amp; s = printContext.parameters().a1.get();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">        printContext.parameters().r.set( (<span class="keywordtype">int</span>) s.length() );</div><div class="line">        printContext.commit();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Once created, the <code><a class="el" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext</a>&lt;&gt;</code> objects can be stored and copied like any other C++ object. When the <code>Print()</code> function returns, RCF will not send a response to the client. The response will only be sent when <code><a class="el" href="class_r_c_f_1_1_remote_call_context.html">RCF::RemoteCallContext</a>&lt;&gt;::commit()</code> is called.</p>
<p><code><a class="el" href="class_r_c_f_1_1_remote_call_context.html#a21d3e4331f8093a0ce66643311819402" title="Provides access to the parameters of a remote call context. ">RCF::RemoteCallContext::parameters()</a></code> provides access to all the parameters of the remote call, including the return value. The code sample above accesses an in-parameter:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> std::string &amp; s = printContext.parameters().a1.get();</div></div><!-- fragment --><p> , and subsequently sets an out-parameter (in this case the return value):</p>
<div class="fragment"><div class="line">    printContext.parameters().r.set( (<span class="keywordtype">int</span>) s.length() );</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
