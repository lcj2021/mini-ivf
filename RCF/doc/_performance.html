
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_performance.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Performance </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#PerfRemoteCalls">Remote calls</a><ul><li class="level2"><a href="#ZeroCopy">Zero Copy</a></li>
<li class="level2"><a href="#ZeroAllocation">Zero Allocation</a></li>
</ul>
</li>
<li class="level1"><a href="#Caching">Object Caching</a></li>
<li class="level1"><a href="#Scalability">Scalability</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="PerfRemoteCalls"></a>
Remote calls</h1>
<p>RCF has been designed with two key performance characteristics in mind. When executing repeated remote calls on a single connection, critical code paths in RCF's server and client implementation adhere to the following two principles:</p>
<ul>
<li><b>Zero copy</b> - No internal copies are made of remote call parameters or buffers.</li>
<li><b>Zero allocation</b> - No memory allocations are made.</li>
</ul>
<h2><a class="anchor" id="ZeroCopy"></a>
Zero Copy</h2>
<p>RCF makes no internal copies of remote call parameters or data while sending or receiving, either on the server or the client.</p>
<p>You should note, however, that serialization may force copies to be made. For instance, deserializing a <code>std::string</code> is not possible without making a copy of the string contents, because <code>std::string</code> always allocates its own storage. The same applies to <code>std::vector&lt;&gt;</code>.</p>
<p>To pass buffers of data through a remote call, without making any copies, RCF provides the <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code> class. The contents of a <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code> are not copied upon serialization or deserialization, and instead RCF uses scatter/gather style semantics to send and receive the contents directly.</p>
<p>This means that if you are transferring large chunks of untyped data through a remote call, you should use <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code>, rather than containers like <code>std::string</code> or <code>std::vector</code>. On typical hardware, transferring multiple megabytes of data in a single call will not stress the system at all.</p>
<h2><a class="anchor" id="ZeroAllocation"></a>
Zero Allocation</h2>
<p>RCF makes a minimum of memory allocations on critical paths, in both client and server code. In particular, if a remote call is made twice with identical parameters, on the same connection, RCF will not make any heap allocations on the second call, either on the client or on the server.</p>
<p>You can verify this by running the code sample below, which overrides <code>operator new</code> to trap any memory allocations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> gExpectAllocations = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// Override global operator new so we can intercept heap allocations.</span></div><div class="line"><span class="keywordtype">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keywordtype">size_t</span> bytes)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (!gExpectAllocations)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unexpected heap allocation!&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> malloc(bytes);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span> (<span class="keywordtype">void</span> *pv) <span class="keywordflow">throw</span>()</div><div class="line">{</div><div class="line">    free(pv);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Override global operator new[] so we can intercept heap allocations.</span></div><div class="line"><span class="keywordtype">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span> [](<span class="keywordtype">size_t</span> bytes)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (!gExpectAllocations)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unexpected heap allocation!&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> malloc(bytes);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span> [](<span class="keywordtype">void</span> *pv) <span class="keywordflow">throw</span>()</div><div class="line">{</div><div class="line">    free(pv);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><div class="fragment"><div class="line">RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)</div><div class="line">    RCF_METHOD_R1(<a class="code" href="namespace_r_c_f.html">RCF</a>::ByteBuffer, Echo, <a class="code" href="namespace_r_c_f.html">RCF</a>::ByteBuffer)</div><div class="line">RCF_END(I_Echo)</div><div class="line"></div><div class="line">class EchoImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a> Echo(<a class="code" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a> byteBuffer)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> byteBuffer;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">    RcfClient&lt;I_Echo&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port)));</div><div class="line"></div><div class="line">    <span class="comment">// First call will trigger some heap allocations.</span></div><div class="line">    gExpectAllocations = <span class="keyword">true</span>;</div><div class="line">    client.Echo(byteBuffer);</div><div class="line"></div><div class="line">    <span class="comment">// These calls won&#39;t trigger any client-side or server-side heap allocations.</span></div><div class="line">    gExpectAllocations = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">for</span> (std::size_t i=0; i&lt;10; ++i)</div><div class="line">    {</div><div class="line">        <a class="code" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a> byteBuffer2 = client.Echo(byteBuffer);</div><div class="line">    }</div></div><!-- fragment --><p> In this code sample we are using <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code> as a parameter, which avoids any allocations being made as part of deserialization.</p>
<p>Typically your code will deserialize objects more complex than <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code> though, and the deserialization of those objects is likely to cause memory allocations to be made. To eliminate such allocations, RCF provides a object cache which can be used to cache commonly occuring object types.</p>
<h1><a class="anchor" id="Caching"></a>
Object Caching</h1>
<p>Serialization and deserialization of remote call parameters can become a performance bottleneck. In particular, deserialization of a complex datatype involves not only creating the object to begin with, but also a number of memory allocations and CPU cycles when deserializing all the fields and subfields of the object.</p>
<p>To improve performance in these circumstances, RCF provides a global cache of objects used during remote calls. Objects used as parameters in one remote call, can be transparently reused in subsequent calls. This means that construction overhead and memory allocations due to deserialization, can be eliminated in subsequent calls.</p>
<p>Here is an example of caching <code>std::string</code> objects:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)</div><div class="line">    RCF_METHOD_R1(std::<span class="keywordtype">string</span>, Echo, std::<span class="keywordtype">string</span>)</div><div class="line">RCF_END(I_Echo)</div><div class="line"></div><div class="line">class EchoImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    std::string Echo(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> s;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line">    EchoImpl echo;</div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(0));</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_Echo&gt;(echo);</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> port = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a109e2e070599daafa3a50446b6336134">getIpServerTransport</a>().<a class="code" href="class_r_c_f_1_1_ip_server_transport.html#a8039d39a935abdf24f5fade86574cac3">getPort</a>();</div><div class="line">    </div><div class="line">    <a class="code" href="class_r_c_f_1_1_object_pool.html">RCF::ObjectPool</a> &amp; cache = RCF::getObjectPool();</div><div class="line"></div><div class="line">    <span class="comment">// Enable caching for std::string.</span></div><div class="line">    <span class="comment">// * Don&#39;t cache more than 10 std::string objects.</span></div><div class="line">    <span class="comment">// * Call std::string::clear() before putting a string into the cache.</span></div><div class="line">    <span class="keyword">auto</span> clearString = [](std::string * pStr) { pStr-&gt;clear(); };</div><div class="line">    cache.<a class="code" href="class_r_c_f_1_1_object_pool.html#ab0729ea93ed136d2a991a8f7076c235e">enableCaching</a>&lt;std::string&gt;(10, clearString);</div><div class="line"></div><div class="line">    std::string s1 = <span class="stringliteral">&quot;123456789012345678901234567890&quot;</span>;</div><div class="line">    std::string s2;</div><div class="line"></div><div class="line">    RcfClient&lt;I_Echo&gt; client(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(port) ));</div><div class="line"></div><div class="line">    <span class="comment">// First call.</span></div><div class="line">    s2 = client.Echo(s1);</div><div class="line"></div><div class="line">    <span class="comment">// Subsequent calls - no memory allocations at all, in RCF runtime, or </span></div><div class="line">    <span class="comment">// in std::string serialization/deserialization, on client or server.</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i=0; i&lt;100; ++i)</div><div class="line">    {</div><div class="line">        s2 = client.Echo(s1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Disable caching for std::string.</span></div><div class="line">    cache.<a class="code" href="class_r_c_f_1_1_object_pool.html#a102c01a6abae103bf1afc7455bf21387">disableCaching</a>&lt;std::string&gt;();</div></div><!-- fragment --><p> In this example, the first call to <code>Echo()</code> will cause several server-side deserialization-related memory allocations - one to construct a <code>std::string</code>, and another to expand the internal buffer of the string, to fit the incoming data.</p>
<p>With object caching enabled, after the call returns, the server-side string is cleared and then held in the object cache, rather than being destroyed. On the next call, instead of constructing a new <code>std::string</code>, RCF reuses the <code>std::string</code> in the cache. Upon deserialization, <code>std::string::resize()</code> is called, to fit the incoming data. As this particular string object has already held the requested amount of data earlier, the <code>resize()</code> request does not result in any memory allocation.</p>
<p>The object cache is configured on a per-type basis, using the <code><a class="el" href="class_r_c_f_1_1_object_pool.html#ab0729ea93ed136d2a991a8f7076c235e">RCF::ObjectPool::enableCaching</a>&lt;&gt;()</code> and <code><a class="el" href="class_r_c_f_1_1_object_pool.html#a102c01a6abae103bf1afc7455bf21387" title="Disables caching of objects of type T. ">RCF::ObjectPool::disableCaching</a>&lt;&gt;()</code> functions. For each cached datatype, you can specify the maximum number of objects to cache, and which function to call, to put the objects in a reusable state.</p>
<p>The object cache can be used with any C++ type, not just the types that appear in a RCF interface. If your server-side code repeatedly creates and destroys objects of a particular type, you can enable object caching for that type.</p>
<h1><a class="anchor" id="Scalability"></a>
Scalability</h1>
<p>RCF is built to scale as far as the underlying hardware and operating system allow it.</p>
<p>Scalability is usually of more concern on the server-side than client-side, as servers tend to manage far more network connections than any individual client would.</p>
<p>RCF's server transport implementation is based on <a href="http://think-async.com/Asio/AsioStandalone">Asio</a>, a well-known C++ networking library which has been part of the <a href="http://www.boost.org/libs/asio">Boost</a> library for many years, and will likely form the foundation for a future networking libary in the C++ standard. Asio is a mature and high-performance networking back-end, which leverages native network API's when they are avaialable (I/O completion ports on Windows, <code>epoll()</code> on Linux, <code>/dev/poll</code> on Solaris, <code>kqueue()</code> on FreeBSD), and less performant API's when they aren't (BSD sockets).</p>
<p>As such, the number of clients a RCF server can support is essentially determined by the number of cores and amount of memory available to the server, as well as the application-specific resources required by each client.</p>
<p>RCF has been designed to yield minimal performance overhead, with network intensive, high throughput applications in mind. Keep in mind that bottlenecks in distributed systems tend to be determined by the overall design of the distributed system - a poorly designed distributed system will have its performance cut off well before the communications layer reaches its limit. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
