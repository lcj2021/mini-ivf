
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Remote Call Framework (RCF) - Delta V Software</title>
    <!-- Bootstrap core CSS -->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <!-- JL: Using timestamp here to prevent css file from being cached -->
    <link href="../css/website.css?<?php echo time(); ?>" rel="stylesheet" />
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygenBase.css" rel="stylesheet" type="text/css" />
    <link href="doxyStylesheet.css" rel="stylesheet" type="text/css"/>
<link href="doxySidebarFixes.css" rel="stylesheet" type="text/css"/>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body style="padding-top: 0px">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-fixed-top" style="top: 20px;">
        <!-- <nav class="navbar navbar-expand-lg fixed-top"> -->
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="RCF_Logo_70px.png" height="70" /> </img></a>
            <!--
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" style="padding-top: 0px;">
                        <a class="nav-link" href="../index.html"><i class="fa fa-home"></i></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../download.html">Download</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../licensing.html">Licensing</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about.html">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../contact.html">Contact</a>
                    </li>
                </ul>
            </div>
                -->
        </div>
    </nav>
        <div class="container">
        <div class="row">
            <div class="col-lg-12">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Remote Call Framework 3.4
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#GettingStarted">Getting Started</a></li>
<li class="level1"><a href="#Tutorial_Interfaces">Interfaces</a></li>
<li class="level1"><a href="#Tutorial_Serialization">Serialization</a></li>
<li class="level1"><a href="#Tutorial_ClientStubs">Client Stubs</a></li>
<li class="level1"><a href="#Tutorial_ServerSessions">Server Sessions</a></li>
<li class="level1"><a href="#Tutorial_Transports">Transports</a></li>
<li class="level1"><a href="#Tutorial_Encryption">Encryption and Authentication</a></li>
<li class="level1"><a href="#Tutorial_Threading">Server Threading</a></li>
<li class="level1"><a href="#Tutorial_AsyncCalls">Asynchronous Remote Calls</a></li>
<li class="level1"><a href="#Tutorial_PubSub">Publish/subscribe</a></li>
<li class="level1"><a href="#Tutorial_FileTransfers">File Transfers</a></li>
</ul>
</div>
<div class="textblock"><p>So, what is <b>Remote Call Framework</b> (<b>RCF</b>), and what would you use it for?</p>
<p>RCF is a C++ library that allows you to make remote calls between C++ processes. RCF provides a clean and simple solution for getting multiple C++ processes talking to each other, with a minimum of overhead and a minimum of complexity.</p>
<p>The simplest way to understand how RCF works is to just jump in and get started with an example. This tutorial presents a simple RCF-based client and server, and subsequently uses them to introduce fundamental RCF features.</p>
<h1><a class="anchor" id="GettingStarted"></a>
Getting Started</h1>
<p>We'll start off with a simple TCP-based client and server. We want to write a server exposting a print service, which receives messages from clients and prints them to standard output.</p>
<p>This is the server:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;RCF/RCF.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define the I_PrintService RCF interface.</span></div><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line"><span class="comment">// Server implementation of the I_PrintService RCF interface.</span></div><div class="line">class PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Initialize RCF.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_init.html">RCF::RcfInit</a> rcfInit;</div><div class="line"></div><div class="line">        <span class="comment">// Instantiate a RCF server.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001));</div><div class="line"></div><div class="line">        <span class="comment">// Bind the I_PrintService interface.</span></div><div class="line">        PrintService printService;</div><div class="line">        server.bind&lt;I_PrintService&gt;(printService);</div><div class="line"></div><div class="line">        <span class="comment">// Start the server.</span></div><div class="line">        server.start();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Press Enter to exit...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cin.get();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> ( <span class="keyword">const</span> <a class="code" href="class_r_c_f_1_1_exception.html">RCF::Exception</a> &amp; e )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e.<a class="code" href="class_r_c_f_1_1_exception.html#a212dab5607ff88c44f99d602480fd6b3">getErrorMessage</a>() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> And this is the client:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;RCF/RCF.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define the I_PrintService RCF interface.</span></div><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Initialize RCF.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_init.html">RCF::RcfInit</a> rcfInit;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Calling the I_PrintService Print() method.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        </div><div class="line">        <span class="comment">// Instantiate a RCF client.</span></div><div class="line">        RcfClient&lt;I_PrintService&gt; client(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001));</div><div class="line"></div><div class="line">        <span class="comment">// Connect to the server and call the Print() method.</span></div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> ( <span class="keyword">const</span> <a class="code" href="class_r_c_f_1_1_exception.html">RCF::Exception</a> &amp; e )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e.<a class="code" href="class_r_c_f_1_1_exception.html#a212dab5607ff88c44f99d602480fd6b3">getErrorMessage</a>() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The code should be fairly self-explanatory.</p>
<p>To build the code, copy it into a C++ source file, and then compile it along with <code>RCF.cpp</code> (available in the distribution at <code>&lt;rcf_distro&gt;/src/RCF/RCF.cpp</code>, where <code>&lt;rcf_distro&gt;</code> is the location at which you have unpacked the RCF distribution). You will also need to add <code>&lt;rcf_distro&gt;/include</code> to your compilers include directories. More information on building is available in <a class="el" href="_building_r_c_f.html">Building RCF</a>.</p>
<p>Let's now start the server:</p>
<div class="fragment"><div class="line">c:\Projects\RcfSample\Debug&gt;Server.exe</div><div class="line">Press Enter to exit...</div></div><!-- fragment --><p>, followed by the client:</p>
<div class="fragment"><div class="line">c:\Projects\RcfSample\Debug&gt;Client.exe</div><div class="line">Calling the I_PrintService Print() method.</div><div class="line">c:\Projects\RcfSample\Debug&gt;</div></div><!-- fragment --><p>In the server window, you should now see:</p>
<div class="fragment"><div class="line">c:\Projects\RcfSample\Debug&gt;Server.exe</div><div class="line">Press Enter to exit...</div><div class="line">I_PrintService service: Hello World</div></div><!-- fragment --><p>So far, so good.</p>
<p>To make it easier to run and debug the code, we can rewrite our print service application so that the client and server run in a single process:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;RCF/RCF.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define the I_PrintService RCF interface.</span></div><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line"><span class="comment">// Server implementation of the I_PrintService RCF interface.</span></div><div class="line">class PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="comment">// Initialize RCF.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_init.html">RCF::RcfInit</a> rcfInit;</div><div class="line"></div><div class="line">        <span class="comment">// Instantiate a RCF server.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div><div class="line"></div><div class="line">        <span class="comment">// Bind the I_PrintService interface.</span></div><div class="line">        PrintService printService;</div><div class="line">        server.bind&lt;I_PrintService&gt;(printService);</div><div class="line">        </div><div class="line">        <span class="comment">// Start the server.</span></div><div class="line">        server.start();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Calling the I_PrintService Print() method.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// Instantiate a RCF client.</span></div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div><div class="line"></div><div class="line">        <span class="comment">// Connect to the server and call the Print() method.</span></div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> ( <span class="keyword">const</span> <a class="code" href="class_r_c_f_1_1_exception.html">RCF::Exception</a> &amp; e )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e.<a class="code" href="class_r_c_f_1_1_exception.html#a212dab5607ff88c44f99d602480fd6b3">getErrorMessage</a>() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Running this program yields the output:</p>
<div class="fragment"><div class="line">Calling the I_PrintService Print() method.</div><div class="line">I_PrintService service: Hello World</div></div><!-- fragment --><p>Let's summarize what we have at this point:</p>
<ul>
<li>A TCP server listening on port 50001 of the localhost (<code>127.0.0.1</code>) interface.</li>
<li>A client establishing a single TCP connection to <code>127.0.0.1:50001</code>, and communicating in clear text with the server.</li>
<li>The server is able to scale out to as many concurrent client connections as the local system resources allow. A typical system will easily handle many thousands of client connections.</li>
<li>As written, the server is single-threaded. So regardless of how many clients are connected concurrently, there is no risk of concurrent access to <code>std::cout</code>.</li>
</ul>
<p>The rest of the tutorial will build on this example, to illustrate some of the fundamental features of RCF.</p>
<h1><a class="anchor" id="Tutorial_Interfaces"></a>
Interfaces</h1>
<p>RCF interfaces are defined in C++, directly in your code. You define RCF interfaces much as you would define any other C++ code, and then bind those interfaces directly to your C++ client and server code.</p>
<p>In the example above, we defined the <code>I_PrintService</code> interface:</p>
<div class="fragment"><div class="line"></div><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div></div><!-- fragment --><p> This code defines the RCF interface <code>I_PrintService</code>. The interface contains a single method <code>Print()</code>. The <code>Print()</code> method has a void return type and takes a single <code>const std::string &amp;</code> parameter.</p>
<p>The <code>RCF_METHOD_&lt;xx&gt;()</code> macros are used to define remote methods. <code>RCF_METHOD_V1()</code> defines a remote method with a void return type and one parameter. <code>RCF_METHOD_R2()</code> defines a remote method with a non-void return type and two parameters, and so on. The <code>RCF_METHOD_&lt;xx&gt;()</code> macros are defined for methods with void and non-void return types, taking up to 15 parameters.</p>
<p>On the server, the RCF interface is bound to a servant object:</p>
<div class="fragment"><div class="line"></div><div class="line">    server.bind&lt;I_PrintService&gt;(printService);</div><div class="line"></div></div><!-- fragment --><p> The server will now route incoming remote calls on the <code>I_PrintService</code> interface, to the <code>printService</code> object.</p>
<p>Let's add a few more methods to the <code>I_PrintService</code> interface. We'll add methods to print a list of strings, and return the number of characters printed:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// Include serialization code for std::vector&lt;&gt;.</span></div><div class="line"><span class="preprocessor">#include &lt;SF/vector.hpp&gt;</span></div><div class="line"></div><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Print a string.</span></div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)                         </div><div class="line"></div><div class="line">    <span class="comment">// Print a list of strings. Returns number of characters printed.</span></div><div class="line">    RCF_METHOD_R1(<span class="keywordtype">int</span>,  Print, const std::vector&lt;std::<span class="keywordtype">string</span>&gt; &amp;)    </div><div class="line"></div><div class="line">    <span class="comment">// Print a list of strings. Returns number of characters printed.</span></div><div class="line">    RCF_METHOD_V2(<span class="keywordtype">void</span>, Print, const std::vector&lt;std::<span class="keywordtype">string</span>&gt; &amp;, <span class="keywordtype">int</span> &amp;)     </div><div class="line"></div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div></div><!-- fragment --><p> Having added these methods to the <code>I_PrintService</code> interface, we also need to implement them in the <code>PrintService</code> servant object:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> Print(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp; v)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> howManyChars = 0;</div><div class="line">        <span class="keywordflow">for</span> (std::size_t i=0; i&lt;v.size(); ++i)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; v[i] &lt;&lt; std::endl;</div><div class="line">            howManyChars += (int) v[i].size();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> howManyChars;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp; v, <span class="keywordtype">int</span> &amp; howManyChars)</div><div class="line">    {</div><div class="line">        howManyChars = 0;</div><div class="line">        <span class="keywordflow">for</span> (std::size_t i=0; i&lt;v.size(); ++i)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; v[i] &lt;&lt; std::endl;</div><div class="line">            howManyChars += (int) v[i].size();</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Here is how we would call the new <code>Print()</code> methods:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; stringsToPrint;</div><div class="line">    stringsToPrint.push_back(<span class="stringliteral">&quot;First message&quot;</span>);</div><div class="line">    stringsToPrint.push_back(<span class="stringliteral">&quot;Second message&quot;</span>);</div><div class="line">    stringsToPrint.push_back(<span class="stringliteral">&quot;Third message&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Remote call returning argument through return value.</span></div><div class="line">    <span class="keywordtype">int</span> howManyChars = client.Print(stringsToPrint);</div><div class="line"></div><div class="line">    <span class="comment">// Remote call returning argument through non-const reference parameter.</span></div><div class="line">    client.Print(stringsToPrint, howManyChars);</div></div><!-- fragment --> <h1><a class="anchor" id="Tutorial_Serialization"></a>
Serialization</h1>
<p>As part of executing a remote call, RCF serializes the parameters of the remote call into a byte sequence and transmits them over a network connection. On the other side of the connection, RCF deserializes the parameters from a byte sequence back into actual C++ objects.</p>
<p>RCF handles serialization of most standard C++ data types automatically. All you need to do is include the relevant serialization header for the data types you are using. A table of standard C++ data types, along with their RCF serialization headers, is available in the section on <a class="el" href="_serialization.html">Serialization</a>.</p>
<p>You can also use your own application data types as parameters in remote calls. In that case you will need to provide serialization functions for those data types.</p>
<p>So far we've only used standard C++ data types in the <code>I_PrintService</code> interface. Imagine now that we want to add a <code>Print()</code> method to the <code>I_PrintService</code> interface, that takes an application-specific <code>LogMessage</code> structure, with <code>LogMessage</code> defined as follows:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">enum</span> LogSeverity</div><div class="line">{</div><div class="line">    Critical, Error, Warning, Informative</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>LogMessage</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    std::string     mUserName;</div><div class="line">    <span class="keywordtype">int</span>             mThreadId = 0;</div><div class="line">    LogSeverity     mSeverity = Informative;</div><div class="line">    <span class="keywordtype">int</span>             mDurationMs = 0;</div><div class="line">    std::string     mMessage;</div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> Before we can use the <code>LogMessage</code> class in a RCF interface, we need to provide a RCF serialization function for it.</p>
<p>Serialization functions are generally quite simple to write. They can be provided as member functions, or as free standing global functions within the same namespace as the class being serialized.</p>
<p>The serialization function for a data type essentially specifies which members take part in serialization, and is called whenever RCF needs to serialize or deserialize an object of that type.</p>
<p>Serialization functions can be member functions, or free standing functions. Here is a serialization member function for <code>LogMessage</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LogMessage::serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a>&amp; ar)</div><div class="line">{</div><div class="line">    ar &amp; mUserName;</div><div class="line">    ar &amp; mThreadId;</div><div class="line">    ar &amp; mSeverity;</div><div class="line">    ar &amp; mDurationMs;</div><div class="line">    ar &amp; mMessage;</div><div class="line">}</div></div><!-- fragment --><p> If we wanted to use a free standing function instead, it would look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> serialize(<a class="code" href="class_s_f_1_1_archive.html">SF::Archive</a>&amp; ar, LogMessage&amp; msg)</div><div class="line">{</div><div class="line">    ar &amp; msg.mUserName;</div><div class="line">    ar &amp; msg.mThreadId;</div><div class="line">    ar &amp; msg.mSeverity;</div><div class="line">    ar &amp; msg.mDurationMs;</div><div class="line">    ar &amp; msg.mMessage;</div><div class="line">}</div></div><!-- fragment --><p> And that's it. We can now add a method to the <code>I_PrintService</code> interface:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Print a string.</span></div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line"></div><div class="line">    <span class="comment">// Print a LogMessage.</span></div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const LogMessage &amp;)</div><div class="line"></div><div class="line">RCF_END(I_PrintService)</div></div><!-- fragment --><p> , and call it from a client:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001));</div><div class="line"></div><div class="line">    LogMessage msg;</div><div class="line">    client.Print(msg);</div></div><!-- fragment --><h1><a class="anchor" id="Tutorial_ClientStubs"></a>
Client Stubs</h1>
<p>Remote calls are always made through a <code>RcfClient&lt;&gt;</code> instance. Each <code>RcfClient&lt;&gt;</code> instance contains a <code><a class="el" href="class_r_c_f_1_1_client_stub.html" title="Controls the client side of a RCF connection. ">RCF::ClientStub</a></code>, which can be accessed by calling <code>RcfClient&lt;&gt;::getClientStub()</code>. <code><a class="el" href="class_r_c_f_1_1_client_stub.html" title="Controls the client side of a RCF connection. ">RCF::ClientStub</a></code> is where almost all client side configuration of remote calls takes place.</p>
<p>Two important client side settings are the connection timeout and the remote call timeout. The connection timeout determines how long the client will wait while trying to establish a network connection to the server, while the remote call timeout determines how long the client will wait for a remote call response to return from the server.</p>
<p>To change these settings, call the <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a6c17010d3692c26f7c6c0c003898a373" title="Sets the connect timeout. ">RCF::ClientStub::setConnectTimeoutMs()</a></code> and <code><a class="el" href="class_r_c_f_1_1_client_stub.html#af913a97d88fed06930810c959c47deac" title="Sets the remote call timeout. ">RCF::ClientStub::setRemoteCallTimeoutMs()</a></code> functions:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <span class="comment">// 5 second timeout when establishing network connection.</span></div><div class="line">    client.getClientStub().setConnectTimeoutMs(5*1000);</div><div class="line"></div><div class="line">    <span class="comment">// 60 second timeout when waiting for remote call response from the server.</span></div><div class="line">    client.getClientStub().setRemoteCallTimeoutMs(60*1000);</div><div class="line"></div><div class="line">    client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> Another commonly used client-side configuration setting is the remote call progress callback, configured through <code><a class="el" href="class_r_c_f_1_1_client_stub.html#abf046b1173ece9d2a5c5ae5c6e408a65">RCF::ClientStub::setRemoteCallProgressCallback()</a></code>. This allows you to monitor or cancel a remote call while it is in progress:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> progressCallback = [&amp;](<span class="keyword">const</span> <a class="code" href="class_r_c_f_1_1_remote_call_progress_info.html">RCF::RemoteCallProgressInfo</a> &amp; info, <a class="code" href="group___r_c_f.html#gacbd77f925dc515e537b44b3ec25d0cd7">RCF::RemoteCallAction</a>&amp; action) </div><div class="line">    { </div><div class="line">        <span class="comment">// To cancel the call, set action to RCF::Rca_Cancel:</span></div><div class="line">        <span class="comment">//action = RCF::Rca_Cancel;</span></div><div class="line">        action = <a class="code" href="group___r_c_f.html#ggacbd77f925dc515e537b44b3ec25d0cd7af19593972404be5986fba07b37e06ec4">RCF::Rca_Continue</a>;</div><div class="line">    };</div><div class="line"></div><div class="line">    client.getClientStub().setRemoteCallProgressCallback(</div><div class="line">        progressCallback,</div><div class="line">        500);</div><div class="line"></div><div class="line">    <span class="comment">// While the call is executing, the progress callback will be called every 500ms.</span></div><div class="line">    client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> There are many other client-side configuration settings, documented in <code><a class="el" href="class_r_c_f_1_1_client_stub.html" title="Controls the client side of a RCF connection. ">RCF::ClientStub</a></code>.You can read more about client side configuration in <a class="el" href="_clientside.html">Client-side programming</a>.</p>
<h1><a class="anchor" id="Tutorial_ServerSessions"></a>
Server Sessions</h1>
<p>On the client-side every <code>RcfClient&lt;&gt;</code> instance controls a single network connection to the server. On the server-side, RCF maintains a session (<code><a class="el" href="class_r_c_f_1_1_rcf_session.html" title="Represents a server side session, associated with a client connection. ">RCF::RcfSession</a></code>) for every such connection to the server. The <code>RcfSession</code> of a client connection is available to server-side code through the global <code><a class="el" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2" title="Can only be called from within the server-side implementation of a remote call. Returns a reference t...">RCF::getCurrentRcfSession()</a></code> function.</p>
<p>You can use <code>RcfSession</code> to maintain application data specific to a particular client connection. Arbitrary C++ objects can be stored in a session by calling <code><a class="el" href="class_r_c_f_1_1_rcf_session.html#a1632a13e375dcaabb28cc8df3e7926f3" title="Creates a session object. ">RCF::RcfSession::createSessionObject</a>&lt;&gt;()</code> or <code><a class="el" href="class_r_c_f_1_1_rcf_session.html#ae0de2d50513e2e7c75c8363352430fa0" title="Retrieves a session object, and optionally creates it. ">RCF::RcfSession::getSessionObject</a>&lt;&gt;()</code>.</p>
<p>For instance, here is how we would associate a <code>PrintServiceSession</code> object with each client connection to the <code>I_PrintService</code> interface, to tracks the numer of calls made on that connection:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintServiceSession</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PrintServiceSession() : mCallCount(0)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Created PrintServiceSession object.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    ~PrintServiceSession()</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Destroyed PrintServiceSession object.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::size_t mCallCount;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Creates the session object if it doesn&#39;t already exist.</span></div><div class="line">        PrintServiceSession &amp; printSession = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#ae0de2d50513e2e7c75c8363352430fa0">getSessionObject</a>&lt;PrintServiceSession&gt;(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        ++printSession.mCallCount;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;Total calls on this connection so far: &quot;</span> &lt;&lt; printSession.mCallCount &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Distinct <code>RcfClient&lt;&gt;</code> instances will have distinct connections to the server. Here we are calling <code>Print()</code> three times from two <code>RcfClient&lt;&gt;</code> instances:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (std::size_t i=0; i&lt;2; ++i)</div><div class="line">    {</div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">    }</div></div><!-- fragment --><p> , resulting in the following output:</p>
<div class="fragment"><div class="line">Created PrintServiceSession object.</div><div class="line">I_PrintService service: Hello World</div><div class="line">I_PrintService service: Total calls on this connection so far: 1</div><div class="line">I_PrintService service: Hello World</div><div class="line">I_PrintService service: Total calls on this connection so far: 2</div><div class="line">I_PrintService service: Hello World</div><div class="line">I_PrintService service: Total calls on this connection so far: 3</div><div class="line">Destroyed PrintServiceSession object.</div><div class="line">Created PrintServiceSession object.</div><div class="line">I_PrintService service: Hello World</div><div class="line">I_PrintService service: Total calls on this connection so far: 1</div><div class="line">I_PrintService service: Hello World</div><div class="line">I_PrintService service: Total calls on this connection so far: 2</div><div class="line">I_PrintService service: Hello World</div><div class="line">I_PrintService service: Total calls on this connection so far: 3</div><div class="line">Destroyed PrintServiceSession object.</div></div><!-- fragment --><p>The server session and any associated session objects are destroyed when the client connection is closed.</p>
<p>See <a class="el" href="_serverside.html">Server-side programming</a> for more about server sessions.</p>
<h1><a class="anchor" id="Tutorial_Transports"></a>
Transports</h1>
<p>In RCF, the transport layer handles transmission of messages across network connections. The transport layer is determined by the endpoint parameters passed to the <code>RcfServer</code> and <code>RcfClient&lt;&gt;</code> constructors. So far we've been using <code><a class="el" href="class_r_c_f_1_1_tcp_endpoint.html" title="Represents a TCP endpoint. ">RCF::TcpEndpoint</a></code>, to specify a TCP transport.</p>
<p>By default, when you specify a <code><a class="el" href="class_r_c_f_1_1_tcp_endpoint.html" title="Represents a TCP endpoint. ">RCF::TcpEndpoint</a></code> with only a port number, RCF will use <code>127.0.0.1</code> as the IP address. So the following two snippets are equivalent:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div></div><!-- fragment --><p> , as are the following:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div></div><!-- fragment --><div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 50001) );</div></div><!-- fragment --><p> <code>127.0.0.1</code> is the IPv4 loopback address. A server listening on <code>127.0.0.1</code> will only be accessible to clients on the same machine as the server. It's likely you'll want to run clients across the network, in which case the server will need to listen on an externally visible network address. To do that, specify <code>0.0.0.0</code> (for IPv4), or <code>::0</code> (for IPv6) instead, which will make the server listen on all available network interfaces:</p>
<div class="fragment"><div class="line">        <span class="comment">// Server listening for TCP connections on all network interfaces.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001) );</div><div class="line"></div><div class="line">        <span class="comment">// Client connecting to TCP server on &quot;printsvr.acme.com&quot;.</span></div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;printsvr.acme.com&quot;</span>, 50001) );</div></div><!-- fragment --><p> RCF supports a number of other endpoint types as well. To run a server and client over UDP, use <code><a class="el" href="class_r_c_f_1_1_udp_endpoint.html" title="Represents a UDP endpoint. ">RCF::UdpEndpoint</a></code>:</p>
<div class="fragment"><div class="line">        <span class="comment">// Server listening for UDP messages on all network interfaces.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001) );</div><div class="line"></div><div class="line">        <span class="comment">// Client sending UDP messages to UDP server on &quot;printsvr.acme.com&quot;.</span></div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;printsvr.acme.com&quot;</span>, 50001) );</div></div><!-- fragment --><p> It's usually not practical to use UDP for two-way (request/response) messaging, as the unreliable semantics of UDP mean that messages may not be delivered, or may be delivered out of order. UDP is useful in one-way messaging scenarios, where the server application logic is resilient to messages being lost or arriving out of order.</p>
<p>To run a server and client over named pipes, use <code><a class="el" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html" title="Represents a Win32 named pipe endpoint. Only available on Windows platforms. ">RCF::Win32NamedPipeEndpoint</a></code> (for Windows named pipes) or <code><a class="el" href="class_r_c_f_1_1_unix_local_endpoint.html" title="Represents a UNIX local socket endpoint. Only available on UNIX platforms. ">RCF::UnixLocalEndpoint</a></code> (for UNIX local domain sockets):</p>
<div class="fragment"><div class="line">        <span class="comment">// Server listening for Win32 named pipe connections on pipe &quot;PrintSvrPipe&quot;.</span></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;PrintSvrPipe&quot;</span>) );</div><div class="line"></div><div class="line">        <span class="comment">// Client connecting to Win32 named pipe server named &quot;PrintSvrPipe&quot;.</span></div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;PrintSvrPipe&quot;</span>) );</div></div><!-- fragment --><p> HTTP and HTTPS endpoints are also available, if you need to tunnel remote calls through the HTTP protocol. The most common reason for doing so is to traverse network infrastructure such as HTTP proxies:</p>
<div class="fragment"><div class="line">        <span class="comment">// Server-side.</span></div><div class="line">        PrintService printService;</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_http_endpoint.html">RCF::HttpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 80) );</div><div class="line">        server.bind&lt;I_PrintService&gt;(printService);</div><div class="line">        server.start();</div><div class="line"></div><div class="line">        <span class="comment">// Client-side.</span></div><div class="line">        <span class="comment">// This client will connect to printsvr.acme.com via the HTTP proxy at proxy.acme.com:8080.</span></div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_http_endpoint.html">RCF::HttpEndpoint</a>(<span class="stringliteral">&quot;printsvr.acme.com&quot;</span>, 80) );</div><div class="line">        client.getClientStub().setHttpProxy(<span class="stringliteral">&quot;web-proxy.acme.com&quot;</span>);</div><div class="line">        client.getClientStub().setHttpProxyPort(8080);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> Multiple transports can be configured for a single <code>RcfServer</code>. For example, to configure a server that accepts TCP, UDP and named pipe connections:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50001) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_udp_endpoint.html">RCF::UdpEndpoint</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 50002) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>( <a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;PrintSvrPipe&quot;</span>) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> See <a class="el" href="_transports.html">Transports</a> for more information on transports.</p>
<h1><a class="anchor" id="Tutorial_Encryption"></a>
Encryption and Authentication</h1>
<p>RCF provides a number of options for encryption and authentication of remote calls. Encryption and authentication are provided as transport protocols, layered on top of the transport.</p>
<p>RCF supports the following transport protocols:</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa378749(v=vs.85).aspx">NTLM</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa378747(v=vs.85).aspx">Kerberos</a></li>
<li><a href="http://en.wikipedia.org/wiki/Secure_Socket_Layer">SSL</a></li>
</ul>
<p>The NTLM and Kerberos transport protocols are only supported on Windows. The SSL transport protocol is supported on all platforms, but for non-Windows builds requires RCF to be built with OpenSSL support (see <a class="el" href="_building_r_c_f.html">Building RCF</a>).</p>
<p>A <code>RcfServer</code> can be configured to require its clients to use certain transport protocols:</p>
<div class="fragment"><div class="line">    std::vector&lt;RCF::TransportProtocol&gt; protocols;</div><div class="line">    protocols.push_back(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);</div><div class="line">    protocols.push_back(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a34369316e7f91bdcfd657a4dad125efd">RCF::Tp_Kerberos</a>);</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e504f8db47a9d522b8d6644ca6fd934">setSupportedTransportProtocols</a>(protocols);</div></div><!-- fragment --><p> On the client-side, <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a3e1cbd34dc1006000319356737008a63" title="Sets the transport protocol. ">RCF::ClientStub::setTransportProtocol()</a></code> is used to configure transport protocols. For instance, to enable the NTLM protocol on a client connection:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);</div><div class="line">    client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> In this example, the client will authenticate itself to the server and encrypt its connection using the NTLM protocol, using the implicit Windows credentials of the logged on user.</p>
<p>To provide explicit credentials, use <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a28b76f478a58d93071d9bf787f277861" title="Sets the user name to use for authenticating to the server. ">RCF::ClientStub::setUserName()</a></code> and <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a071fbc1a0676644cf2d2ad34687b40d2" title="Sets the password to use when authenticating to the server. ">RCF::ClientStub::setPassword()</a></code>:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);</div><div class="line">        client.getClientStub().setUserName(<span class="stringliteral">&quot;SomeDomain\\Joe&quot;</span>);</div><div class="line">        client.getClientStub().setPassword(<span class="stringliteral">&quot;JoesPassword&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> The Kerberos protocol can be configured similarly. The Kerberos protocol requires the client to supply the Service Principal Name (SPN) of the server. You can do this by calling <code><a class="el" href="class_r_c_f_1_1_client_stub.html#ada49b9ef2cecec36a0723e61cbe09914" title="Sets the Kerberos SPN to use when authenticating to the server. ">RCF::ClientStub::setKerberosSpn()</a></code>:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a34369316e7f91bdcfd657a4dad125efd">RCF::Tp_Kerberos</a>);</div><div class="line">        client.getClientStub().setKerberosSpn(<span class="stringliteral">&quot;SomeDomain\\ServerAccount&quot;</span>);</div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> If a client attempts to call <code>Print()</code> without configuring one of the transport protocols required by the server, they will get an error:</p>
<div class="fragment"><div class="line">        <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">            RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">            client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span>(<span class="keyword">const</span> <a class="code" href="class_r_c_f_1_1_exception.html">RCF::Exception</a> &amp; e)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e.<a class="code" href="class_r_c_f_1_1_exception.html#a212dab5607ff88c44f99d602480fd6b3">getErrorMessage</a>() &lt;&lt; std::endl;</div><div class="line">        }</div></div><!-- fragment --> <div class="fragment"><div class="line">Error: Server requires one of the following transport protocols to be used: NTLM, Kerberos.</div></div><!-- fragment --><p>From within the server-side implementation of <code>Print()</code>, you can retrieve the transport protocol in use on the current session. If the transport protocol is NTLM or Kerberos, you can also retrieve the Windows user name of the client, and even impersonate the client:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a> &amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line"></div><div class="line">        <a class="code" href="group___r_c_f.html#ga3f88ae1d5008805d5f75151296c2c9e8">RCF::TransportProtocol</a> protocol = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a282b5988695fbe26d63ccc6ec4f97970">getTransportProtocol</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ( protocol == <a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a> || protocol == <a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8a34369316e7f91bdcfd657a4dad125efd">RCF::Tp_Kerberos</a> )</div><div class="line">        {</div><div class="line">            std::string clientUsername = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a1e300faa8f908cf1bf12cd84d9642f4e">getClientUserName</a>();</div><div class="line"></div><div class="line">            <a class="code" href="class_r_c_f_1_1_sspi_impersonator.html">RCF::SspiImpersonator</a> impersonator(session);</div><div class="line"></div><div class="line">            <span class="comment">// Now running under Windows credentials of client.</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line"></div><div class="line">            <span class="comment">// Impersonation ends when we exit scope.</span></div><div class="line">        }</div><div class="line"></div><div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> RCF also supports using SSL as the transport protocol. RCF provides two SSL implementations, one based on OpenSSL, and the other based on the Windows Schannel security package. The Windows Schannel implementation is used automatically on Windows, while the OpenSSL implementation is used if <code>RCF_FEATURE_OPENSSL=1</code> is defined when building RCF (see <a class="el" href="_building_r_c_f.html">Building RCF</a>).</p>
<p>SSL-enabled servers require a SSL certificate to present to clients. The mechanics of certificate configuration vary depending on which implementation (Schannel or OpenSSL) is being used. Here is an example using the Schannel SSL implementation:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        </div><div class="line">        <a class="code" href="_rcf_fwd_8hpp.html#a46fd2b69771a5849e76bea7a42c8b624">RCF::CertificatePtr</a> serverCertificatePtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_pfx_certificate.html">RCF::PfxCertificate</a>(</div><div class="line">            <span class="stringliteral">&quot;C:\\ServerCert.p12&quot;</span>, </div><div class="line">            <span class="stringliteral">&quot;Password&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;CertificateName&quot;</span>) );</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a5e870568919107b46301743d7de39b83">setCertificate</a>(serverCertificatePtr);</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div><div class="line"></div><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa8b10df13dfa056f392358446881f316">RCF::Tp_Ssl</a>);</div><div class="line">        client.getClientStub().setEnableSchannelCertificateValidation(<span class="stringliteral">&quot;localhost&quot;</span>);</div></div><!-- fragment --><p> <code><a class="el" href="class_r_c_f_1_1_pfx_certificate.html" title="Use this class to load a certificate from .pfx format. Only applicable to Schannel. ">RCF::PfxCertificate</a></code> is used to load PKCS #12 certificates, from <code>.pfx</code> and <code>.p12</code> files. RCF also provides the <code><a class="el" href="class_r_c_f_1_1_store_certificate.html" title="Represents a certificate in a Windows certificate store. ">RCF::StoreCertificate</a></code> class, to load certificates from a Windows certificate store.</p>
<p>If instead you are using OpenSSL, you can use the <code><a class="el" href="class_r_c_f_1_1_pem_certificate.html" title="Use this class to load a certificate from .pem format. Only applicable to OpenSSL. ">RCF::PemCertificate</a></code> class to load PEM certificates, from <code>.pem</code> files.</p>
<p>RCF supports transport level compression of remote calls, using <a href="zlib.net">zlib</a>. Compression is configured independently of transport protocols, using <code>ClientStub::setEnableCompression()</code>. The compression stage is applied immediately before the transport protocol stage. In other words, remote call data is compressed before being encrypted.</p>
<p>This is an example of a client connecting to a server through an HTTP proxy, using NTLM for authentication and encryption, and with compression enabled:</p>
<div class="fragment"><div class="line">        RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_http_endpoint.html">RCF::HttpEndpoint</a>(<span class="stringliteral">&quot;printsvr.acme.com&quot;</span>, 80) );</div><div class="line">        client.getClientStub().setHttpProxy(<span class="stringliteral">&quot;web-proxy.acme.com&quot;</span>);</div><div class="line">        client.getClientStub().setHttpProxyPort(8080);</div><div class="line">        client.getClientStub().setTransportProtocol(<a class="code" href="group___r_c_f.html#gga3f88ae1d5008805d5f75151296c2c9e8aa5b508bb084f97ea851954999423ef83">RCF::Tp_Ntlm</a>);</div><div class="line">        client.getClientStub().setEnableCompression(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> For more information see <a class="el" href="_transport_protocols.html">Transport protocols</a>.</p>
<h1><a class="anchor" id="Tutorial_Threading"></a>
Server Threading</h1>
<p>By default a <code>RcfServer</code> uses a single thread to handle incoming remote calls, and consequently remote calls are dispatched serially, one after the other. Even if you have multiple transports configured in your server, the transports will all be serviced by a single thread.</p>
<p>This is normally the safest way to run a server, as there is no need for thread synchronization in your server-side application code. You should also be aware that a single-threaded server does not at all limit the number of clients that can concurrently access your server. It only limits the number of remote calls that can execute concurrently. If the remote calls in your application execute quickly, then most likely a single threaded server will be more than sufficient to handle a large number of clients.</p>
<p>However, it is also common to have remote calls that do take some time to execute. For example, your server-side code may be making requests to other backend servers, with potentially significant latency. If the backend server is slow to respond, then the RCF server thread will be blocked for some time and other client requests will be delayed. In this situation, you would need a multi-threaded server in order to be able to continue responding to other clients.</p>
<p>To configure a multi-threaded <code>RcfServer</code>, use <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">RCF::RcfServer::setThreadPool()</a></code> to assign a thread pool to the server. A RCF thread pool can be configured either with a fixed number of threads:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <span class="comment">// Thread pool with fixed number of threads (5).</span></div><div class="line">    RCF::ThreadPoolPtr threadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(5) );</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">setThreadPool</a>(threadPoolPtr);</div><div class="line"></div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> , or a varying number of threads, depending on server load:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">        <span class="comment">// Thread pool with varying number of threads (1 to 25).</span></div><div class="line">        RCF::ThreadPoolPtr threadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1, 25) );</div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">setThreadPool</a>(threadPoolPtr);</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> Thread pools configured through <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a398e68d4418a213fa9605338aea185f6">RCF::RcfServer::setThreadPool()</a></code> are shared across all the transports within the <code>RcfServer</code>. If you want to configure dedicated thread pools for particular transports, you can do so using <code><a class="el" href="class_r_c_f_1_1_server_transport.html#a035886bcaf26a27f33ae201eb6410fee" title="Sets the thread pool that the server transport will use. ">RCF::ServerTransport::setThreadPool()</a></code>:</p>
<div class="fragment"><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server;</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; tcpTransport = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001));</div><div class="line">        <a class="code" href="class_r_c_f_1_1_server_transport.html">RCF::ServerTransport</a> &amp; pipeTransport = server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a431467ee38910f4797080db9e3f30986">addEndpoint</a>(<a class="code" href="class_r_c_f_1_1_win32_named_pipe_endpoint.html">RCF::Win32NamedPipeEndpoint</a>(<span class="stringliteral">&quot;PrintSvrPipe&quot;</span>));</div><div class="line"></div><div class="line">        <span class="comment">// Thread pool with up to 5 threads to serve TCP clients.</span></div><div class="line">        RCF::ThreadPoolPtr tcpThreadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1, 5) );</div><div class="line">        tcpTransport.<a class="code" href="class_r_c_f_1_1_server_transport.html#a035886bcaf26a27f33ae201eb6410fee">setThreadPool</a>(tcpThreadPoolPtr);</div><div class="line"></div><div class="line">        <span class="comment">// Thread pool with single thread to serve named pipe clients.</span></div><div class="line">        RCF::ThreadPoolPtr pipeThreadPoolPtr( <span class="keyword">new</span> <a class="code" href="class_r_c_f_1_1_thread_pool.html">RCF::ThreadPool</a>(1) );</div><div class="line">        pipeTransport.<a class="code" href="class_r_c_f_1_1_server_transport.html#a035886bcaf26a27f33ae201eb6410fee">setThreadPool</a>(pipeThreadPoolPtr);</div><div class="line"></div><div class="line">        server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><h1><a class="anchor" id="Tutorial_AsyncCalls"></a>
Asynchronous Remote Calls</h1>
<p>RCF normally executes remote calls synchronously, and will block the client thread until the call completes. RCF also allows you to execute remote calls asynchronously. Rather than blocking the client thread, the client thread is instead notified at a later point when the remote call has completed.</p>
<p>Asynchronous remote calls are performed in RCF using the <code><a class="el" href="class_r_c_f_1_1_future.html" title="Provides the ability for remote calls to be executed asynchronously. ">RCF::Future</a>&lt;&gt;</code> template. Essentially, for any parameter or return type <code>T</code> in a remote call, if you instead pass in a <code>Future&lt;T&gt;</code>, the remote call will be executed asynchronously. Multiple <code>Future&lt;T&gt;</code> instances can be passed in to a remote call. You can configure the <code>Future&lt;T&gt;</code> instances so that you receive a callback on completion, or you can use <code><a class="el" href="class_r_c_f_1_1_future.html#aa0f8a62c86da3d61bc1160885d302b97" title="Waits for up to timeoutMs ms, for the result of an asynchronous call to become ready. ">RCF::Future::wait()</a></code> or <code><a class="el" href="class_r_c_f_1_1_future.html#a6062726e0e67d49b66ad4f1f94461ff7" title="Tests whether the result of an asynchronous call is ready. ">RCF::Future::ready()</a></code> to check the status of the remote call. Once the remote call has completed, you can use <code><a class="el" href="class_r_c_f_1_1_future.html#ace076992d027efbcab72bdca13376c05" title="Dereferences this Future instance. If the remote call is still in progress, this function will block ...">RCF::Future::operator*()</a></code> to dereference a <code>Future&lt;T&gt;</code> instance and retrieve the actual parameter value.</p>
<p>Given this RCF interface:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_R1(<span class="keywordtype">int</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div></div><!-- fragment --><p> , here is an example of a client that makes an asynchronous calls and then polls for the result to become available:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line"></div><div class="line">    <span class="comment">// Asynchronous remote call.</span></div><div class="line">    <a class="code" href="class_r_c_f_1_1_future.html">RCF::Future&lt;int&gt;</a> fRet = client.Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Wait for the remote call to complete.</span></div><div class="line">    <span class="keywordflow">while</span> ( !fRet.<a class="code" href="class_r_c_f_1_1_future.html#a6062726e0e67d49b66ad4f1f94461ff7">ready</a>() )</div><div class="line">    {</div><div class="line">        RCF::sleepMs(1000);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Check for errors.</span></div><div class="line">    std::unique_ptr&lt;RCF::Exception&gt; ePtr = client.getClientStub().getAsyncException();</div><div class="line">    <span class="keywordflow">if</span> ( ePtr )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ePtr-&gt;getErrorMessage();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Characters printed: &quot;</span> &lt;&lt; *fRet;</div><div class="line">    }</div></div><!-- fragment --><p> Of course, polling for completion is not all that different from making a blocking call. A more powerful technique is to assign a completion callback to the remote call. A completion callback is a function object which RCF will call once the remote call is complete. Here is a simple example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::shared_ptr&lt; RcfClient&lt;I_PrintService&gt; &gt; PrintServicePtr;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> onPrintCompleted(</div><div class="line">    <a class="code" href="class_r_c_f_1_1_future.html">RCF::Future&lt;int&gt;</a> fRet, </div><div class="line">    PrintServicePtr clientPtr)</div><div class="line">{</div><div class="line">    std::unique_ptr&lt;RCF::Exception&gt; ePtr = clientPtr-&gt;getClientStub().getAsyncException();</div><div class="line">    <span class="keywordflow">if</span> ( ePtr )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ePtr-&gt;getErrorMessage();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Characters printed: &quot;</span> &lt;&lt; *fRet;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line">    PrintServicePtr clientPtr(</div><div class="line">        <span class="keyword">new</span> RcfClient&lt;I_PrintService&gt;(<a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001)) );</div><div class="line"></div><div class="line">    <a class="code" href="class_r_c_f_1_1_future.html">RCF::Future&lt;int&gt;</a> fRet;</div><div class="line"></div><div class="line">    <span class="comment">// Asynchronous remote call, with completion callback.</span></div><div class="line">    <span class="keyword">auto</span> onCompletion = [&amp;]() { onPrintCompleted(fRet, clientPtr); };</div><div class="line"></div><div class="line">    fRet = clientPtr-&gt;Print( </div><div class="line">        RCF::AsyncTwoway(onCompletion), </div><div class="line">        <span class="stringliteral">&quot;Hello World&quot;</span>);</div></div><!-- fragment --><p> Note that we've passed both the <code>Future&lt;int&gt;</code> return value and a reference counted client (<code>PrintServicePtr</code>) to the callback. If we were to destroy the client on the main thread, the asynchronous call would be automatically canceled, and the callback would not be called at all.</p>
<p>Asynchronous remote calls are useful in many circumstances. Here is an example of a client calling <code>Print()</code> once every 10 seconds on 50 different servers:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onPrintCompleted(PrintServicePtr clientPtr);</div><div class="line"><span class="keywordtype">void</span> onWaitCompleted(PrintServicePtr clientPtr);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> onPrintCompleted(PrintServicePtr clientPtr)</div><div class="line">{</div><div class="line">    <span class="comment">// Print() call completed. Wait for 10 seconds.</span></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> onCompletion = [&amp;]() { onWaitCompleted(clientPtr); };</div><div class="line"></div><div class="line">    clientPtr-&gt;getClientStub().wait(</div><div class="line">        onCompletion,</div><div class="line">        10 * 1000);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> onWaitCompleted(PrintServicePtr clientPtr)</div><div class="line">{</div><div class="line">    <span class="comment">// 10 second wait completed. Make another Print() call.</span></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> onCompletion = [&amp;]() { onPrintCompleted(clientPtr); };</div><div class="line"></div><div class="line">    clientPtr-&gt;Print( </div><div class="line">        RCF::AsyncTwoway(onCompletion), </div><div class="line">        <span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Addresses to 50 servers.</span></div><div class="line">    std::vector&lt;RCF::TcpEndpoint&gt; servers(50);</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// Create a connection to each server, and make the first call.</span></div><div class="line">    std::vector&lt;PrintServicePtr&gt; clients;</div><div class="line">    <span class="keywordflow">for</span> (std::size_t i=0; i&lt;50; ++i)</div><div class="line">    {</div><div class="line">        PrintServicePtr clientPtr( <span class="keyword">new</span> RcfClient&lt;I_PrintService&gt;(servers[i]) );</div><div class="line">        clients.push_back(clientPtr);</div><div class="line"></div><div class="line">        <span class="comment">// Asynchronous remote call, with completion callback.</span></div><div class="line">        <span class="keyword">auto</span> onCompletion = [&amp;]() { onPrintCompleted(fRet, clientPtr); };</div><div class="line"></div><div class="line">        clientPtr-&gt;Print( </div><div class="line">            RCF::AsyncTwoway(onCompletion), </div><div class="line">            <span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// All 50 servers are now being called once every 10 s.</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// Upon leaving scope, the clients are all automatically destroyed. Any</span></div><div class="line">    <span class="comment">// remote calls in progress are automatically canceled.</span></div></div><!-- fragment --><p> If we had to write this code using synchronous calls, we would need 50 threads, each connecting to one server. By using asynchronous calls, we can manage all 50 connections with a single thread. The remote calls to the 50 servers are all completed on a background RCF thread, and the connections are automatically destroyed when the main thread goes out of scope.</p>
<p>For more information, see <a class="el" href="_async_remote_calls.html">Asynchronous Remote Calls</a>.</p>
<h1><a class="anchor" id="Tutorial_PubSub"></a>
Publish/subscribe</h1>
<p>Imagine that we have a number of <code>I_PrintService</code> servers on our network, and that we want our client to make the same <code>Print()</code> remote call to all of them. To do so using regular two-way remote calls would be tedious. First, we would have to somehow maintain a list of currently available <code>I_PrintService</code> servers. Assuming we had such a list, we would then have to manually call <code>Print()</code> on each server, with the same message.</p>
<p>This kind of scenario is much better suited to a messaging paradigm commonly known as <b>publish/subscribe</b>. The publish/subscribe paradigm is based on a single <b>publisher</b> maintaining a number of <b>publishing topics</b>, and multiple <b>subscribers</b> subscribing to those topics. Whenever the publisher publishes a message on a topic, that message is sent out to all the subscribers subscribing to that particular topic.</p>
<p>The major advantage of the publish/subscribe system is that the publishing code does not need to know anything about the subscribers. The subscribers themselves are responsible for registering for topics they are interested in, while the publisher simply publishes messages.</p>
<p>RCF makes it easy to set up a publish/subscribe system. Publish/subscribe functionality is provided by the <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#a3897d6a968fc0d9c4c04ae2d3c1911f8" title="Creates a publisher instance for the given RCF interface. ">RCF::RcfServer::createPublisher()</a></code> and <code><a class="el" href="class_r_c_f_1_1_rcf_server.html#af8e3e5d679e47140e1560fa2915252d1" title="Creates a subscription to a remote RCF publisher. ">RCF::RcfServer::createSubscription()</a></code> functions. For example, here is code for a publisher publishing a <code>Print()</code> call once every second:</p>
<div class="fragment"><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> publishingServer( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    publishingServer.start();</div><div class="line"></div><div class="line">    <span class="comment">// Start publishing.</span></div><div class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt; RCF::Publisher&lt;I_PrintService&gt; &gt; PrintServicePublisherPtr;</div><div class="line">    PrintServicePublisherPtr pubPtr = publishingServer.createPublisher&lt;I_PrintService&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (shouldContinue())</div><div class="line">    {</div><div class="line">        Sleep(1000);</div><div class="line"></div><div class="line">        <span class="comment">// Publish a Print() call to all currently connected subscribers.</span></div><div class="line">        pubPtr-&gt;publish().Print(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Close the publisher.</span></div><div class="line">    pubPtr-&gt;close();</div></div><!-- fragment --><p> Creating a subscription to this publisher is similarly simple:</p>
<div class="fragment"><div class="line">    <span class="comment">// Start a subscriber.</span></div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> subscriptionServer(( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>() ));</div><div class="line">    subscriptionServer.start();</div><div class="line"></div><div class="line">    PrintService printService;</div><div class="line"></div><div class="line">    RCF::SubscriptionPtr subPtr = subscriptionServer.createSubscription&lt;I_PrintService&gt;(</div><div class="line">        printService, </div><div class="line">        <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001));</div><div class="line"></div><div class="line">    <span class="comment">// At this point Print() will be called on the printService object once a second.</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// Close the subscription.</span></div><div class="line">    subPtr-&gt;close();</div></div><!-- fragment --><p> Published calls are sent out as one way messages to all listening subscribers.</p>
<p>For more information on publish/subscribe messaging, see <a class="el" href="_pub_sub.html">Publish/subscribe</a>.</p>
<h1><a class="anchor" id="Tutorial_FileTransfers"></a>
File Transfers</h1>
<p>File downloads and uploads are common in distributed systems. For smaller files, you can just load them into a <code>std::string</code> (or better, a <code><a class="el" href="class_r_c_f_1_1_byte_buffer.html">RCF::ByteBuffer</a></code>) and send them on their way. This approach breaks down though, for files big enough to exceed the maximum message length of your connection.</p>
<p>Rather than requiring you to split the file into chunks and send the chunks through one by one, RCF provides dedicated functions for downloading and uploading files. These functions take care of the necessary chunking logic, as well as the low level details of concurrent network and disk I/O that are necessary to maximize throughput. RCF also provides the ability to resume interrupted transfers, as well as limiting the amount of bandwidth a file transfer consumes.</p>
<p>For example, here is how we would implement a <code>PrintFile()</code> method on the <code>I_PrintService</code> interface:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, PrintFile, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line">class PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> PrintFile(<span class="keyword">const</span> std::string &amp; uploadId)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; uploadId &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="class_r_c_f_1_1_rcf_session.html">RCF::RcfSession</a>&amp; session = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>();</div><div class="line">        <a class="code" href="_file_system_8hpp.html#acd9dc05ff33e8a344d94fe7fb9421092">RCF::Path</a> pathToFile = session.<a class="code" href="class_r_c_f_1_1_rcf_session.html#a00710bfd731ea2d674b1771f6b1e4618">getUploadPath</a>(uploadId);</div><div class="line">        </div><div class="line">        <span class="comment">// Print file</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        <span class="comment">// Delete file once we&#39;re done with it.</span></div><div class="line">        std::filesystem::remove(pathToFile);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line">    PrintService printService;</div><div class="line">    <a class="code" href="class_r_c_f_1_1_rcf_server.html">RCF::RcfServer</a> server( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a3e8f6a060a87beb96b5690e9829c9c3f">bind</a>&lt;I_PrintService&gt;(printService);</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a2a99bbc9b76aede330a85b5ff640db73">setUploadDirectory</a>(<span class="stringliteral">&quot;C:\\temp&quot;</span>);</div><div class="line">    server.<a class="code" href="class_r_c_f_1_1_rcf_server.html#a737d7cf9860b1d49209b2ebe891e4449">start</a>();</div></div><!-- fragment --><p> Notice that the <code>PrintFile()</code> method takes a upload identifier in the form of a string. To call <code>PrintFile()</code>, the client needs to first use <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a8d2a5dbe6eabef001155c37037ab6984" title="Uploads a file to a RcfServer. The RcfServer must previously have enabled uploads and configured an u...">RCF::ClientStub::uploadFile()</a></code>, to upload the relevant file and obtain a string identifier for the upload. The string identifier is then passed to <code>PrintFile()</code>, which locates the upload on the server, prints the file and then deletes it.</p>
<div class="fragment"><div class="line">    <span class="comment">// Upload files to server.</span></div><div class="line">    <a class="code" href="_file_system_8hpp.html#acd9dc05ff33e8a344d94fe7fb9421092">RCF::Path</a> pathToFile = <span class="stringliteral">&quot;C:\\LargeFile.log&quot;</span>;</div><div class="line">    std::string uploadId = RCF::generateUuid();</div><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    client.getClientStub().uploadFile(uploadId, pathToFile);</div><div class="line">    client.PrintFile(uploadId);</div></div><!-- fragment --><p> Downloading files is done similarly. Here is how we would implement a <code>GetPrintSummary()</code> method, whose purpose is to return a potentially large file to the client:</p>
<div class="fragment"><div class="line">RCF_BEGIN(I_PrintService, <span class="stringliteral">&quot;I_PrintService&quot;</span>)</div><div class="line">    RCF_METHOD_V1(<span class="keywordtype">void</span>, Print, const std::<span class="keywordtype">string</span> &amp;)</div><div class="line">    RCF_METHOD_R0(std::<span class="keywordtype">string</span>, GetPrintSummary)</div><div class="line">RCF_END(I_PrintService)</div><div class="line"></div><div class="line">class PrintService</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Print(<span class="keyword">const</span> std::string &amp; s)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;I_PrintService service: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::string GetPrintSummary()</div><div class="line">    {</div><div class="line">        <a class="code" href="_file_system_8hpp.html#acd9dc05ff33e8a344d94fe7fb9421092">RCF::Path</a> file = <span class="stringliteral">&quot;path/to/download&quot;</span>;</div><div class="line">        std::string downloadId = <a class="code" href="_rcf_session_8hpp.html#a9d9e37f6e66bcbc3a1f6e5775d107cb2">RCF::getCurrentRcfSession</a>().<a class="code" href="class_r_c_f_1_1_rcf_session.html#a924041739db1137b9b0395f573a2ae44">configureDownload</a>(file);</div><div class="line">        <span class="keywordflow">return</span> downloadId;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> <code>GetPrintSummary()</code> configures a download on the server, and then returns the download identifier to the client. The client then calls <code><a class="el" href="class_r_c_f_1_1_client_stub.html#a651399c13f012a6c23c498ec17422930" title="Downloads a file from a RcfServer. The download must already have been configured by the server...">RCF::ClientStub::downloadFile()</a></code> with the download identifier, to download the file:</p>
<div class="fragment"><div class="line">    RcfClient&lt;I_PrintService&gt; client( <a class="code" href="class_r_c_f_1_1_tcp_endpoint.html">RCF::TcpEndpoint</a>(50001) );</div><div class="line">    std::string downloadId = client.GetPrintSummary();</div><div class="line">    <a class="code" href="_file_system_8hpp.html#acd9dc05ff33e8a344d94fe7fb9421092">RCF::Path</a> downloadTo = <span class="stringliteral">&quot;C:\\downloads&quot;</span>;</div><div class="line">    client.getClientStub().downloadFile(downloadId, downloadTo);</div></div><!-- fragment --><p> For more information, see <a class="el" href="_file_transfers.html">File transfers</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!--  -->
    <li class="footer">Copyright (C) <a href="http://www.deltavsoft.com">Delta V Software</a> 2023</li>
    <!-- <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li> -->
  </ul>
</div>
                            </div>
        </div>
    </div>
</body>
</html>
